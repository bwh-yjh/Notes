{"./":{"url":"./","title":"资料","keywords":"","body":""},"学习资料/Java.html":{"url":"学习资料/Java.html","title":"Java","keywords":"","body":""},"学习资料/Java/juc并发编程/并发编程.html":{"url":"学习资料/Java/juc并发编程/并发编程.html","title":"并发编程","keywords":"","body":" 并发编程 一、什么是juc 1.1 juc简介 1.2 进程与线程 1.3 线程的状态 1.3.1 线程状态枚举类 1.3.2 wait/sleep的区别 1.4 并发与并行 1.5 管程 （monitor又称监视器） 1.6 用户线程和守护线程 二、 Lock接口 2.1 Synchronized 2.1.1 Synchronized关键字回顾 2.2 什么是Lock 2.2.1 Lock接口 2.2.2 lock 2.2.3 newCondition 2.3 ReentrantLock 2.4 ReadWriteLock 2.5 小结(重点) 三、线程间通信 3.1 synchronized方案 3.2 Lock 方案 3.3 线程间定制化通信 3.3.1 案例介绍 3.3.2 实现流程 四、 集合的线程安全 4.1 集合操作 4.2 Vector 4.3 Collections 4.4 CopyOnWriteArrayList(重点) 4.5 小结(重点) 五、 多线程锁 5.1 锁的八个问题演示 六、 Callable&Future接口 6.1 Callable接口 6.2 Future接口 6.3 FutureTask 并发编程 一、什么是juc 1.1 juc简介 在 Java 中，线程部分是一个重点，本篇文章说的 JUC 也是关于线程的。JUC 就是 java.util .concurrent 工具包的简称。这是一个处理线程的工具包，JDK 1.5 开始出现的。 1.2 进程与线程 进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程— —资源分配的最小单位。 线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个 单元执行流。线程——程序执行的最小单位。 1.3 线程的状态 1.3.1 线程状态枚举类 1.3.2 wait/sleep的区别 sleep是Thread类的静态方法；wait是Object的方法，任何实例对象都能调用。 sleep不会释放锁，它也不需要占用锁。wait会释放锁，但调用它的前提是当前线程占有锁(即代码要做synchronized中)。 它们都可以被interrupted方法中断。 1.4 并发与并行 并发：同一时刻多个线程再访问同一资源，多个线程对一个点。 例子：春运抢票 电商秒杀..... 并行：多项工作一起执行，之后再汇总 例子：泡方便面------电水壶烧水，一边撕调料包倒入桶中 1.5 管程 （monitor又称监视器） 管程是保证了同一时刻只有一个进程在管程内活动，即管程内定义的操作在同一时刻只能被一个进程调用(由编译器实现)。 JVM同步是基于进入和退出管程对象实现的，每个对象都会有一个管程对象，管程会随着java对象一同创建和销毁。 执行线程首先要持有管程对象，然后才能执行方法，当方法完成之后会释放管程，方法在执行的时候会持有管程，其他线程无法再获取同一个管程。 1.6 用户线程和守护线程 用户线程：平时用到的普通线程，自定义线程 守护线程：运行再后台，是一种特殊的线程 如果主线程结束，用户线程还在运行，JVM存活 如果没有用户现场，都是守护线程，JVM结束 二、 Lock接口 2.1 Synchronized 2.1.1 Synchronized关键字回顾 synchronized是Java中的关键字，是一种同步锁。它的修饰对象有以下几种： 修饰一个代码块，被修饰的代码块被称为同步语句块，其作用的范围是大括号{ }括起来的代码，作用的对象是调用这个代码块的对象； 修饰一个方法，被修饰的方法被称为同步方法，其作用范围是整个方法，作用的对象是调用这个方法的对象； 虽然可以使用 synchronized 来定义方法，但 synchronized 并不属于方法定 义的一部分，因此，synchronized 关键字不能被继承。如果在父类中的某个方 法使用了 synchronized 关键字，而在子类中覆盖了这个方法，在子类中的这 个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上 synchronized 关键字才可以。当然，还可以在子类方法中调用父类中相应的方 法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此， 子类的方法也就相当于同步了。 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 修改一个类，其作用的范围是synchronized后面括号括起来的部分； 如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只有两种情况： 获取锁的线程执行完了代码块，然后线程释放对锁的占有； 线程执行时发生异常，此时JVM会让线程自动释放锁 那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程只能干巴巴的等待，试想一下，多么影响程序的执行效率。 因此就需要有一种机制可以不让等待的线程一直无限期的等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。 2.2 什么是Lock Lock锁实现提供了使用同步方法的语句可以获取的更广泛的锁操作。它们允许更灵活的结构，可能具有不同的属性，并且可能支持多个关联的条件的对象。Lock提供了比synchronized的更多的功能。 Lock与Synchronized区别 Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问； Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。 2.2.1 Lock接口 下面来逐个讲述Lock接口中的每个方法的使用 2.2.2 lock lock()方法是平常使用最多的一个方法，用来获取锁。如果锁已被其他线程获取，则进行等待。 采用Lock，不许主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用try{ }catch{ }块中进行，并且将释放锁的操作放在finally{ }块中进行，以保证锁一定被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的： Lock lock = ...; lock.lock(); try{ //处理任务 }catch(Exception ex){ }finally{ lock.unlock(); //释放锁 } 2.2.3 newCondition 关键字synchronized与wait()/notify这两个方法一起使用可以实现等待/通知模式，Lock锁的newCondition()方法返回Condition对象，Condition类也可以实现等待/通知模式。 用notify()通知时，JVM会随机唤醒某个等待的线程，使用Condition类可以进行选择性通知，Condition比较常用的两个方法： await()会使当前线程等待，同时会释放锁，当其他线程调用signal()时，线程会重新获得锁并继续执行。 signal()用于唤醒一个等待的线程。 注意：在调用Condition的await()/signal方法前，也需要线程持有相关的Lock锁，调用await()后线程会释放这个锁，在singal()调用后会从当前Condition对象的等待队列中，唤醒一个线程，唤醒的线程尝试获得锁，一旦获得锁成功就继续执行 2.3 ReentrantLock ReentrantLock，意思是“可重入锁”，关于可重入锁的概念将在后面讲述。 ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例具体看一下如何使用。 2.4 ReadWriteLock ReadWriteLock也是一个接口，在它里面只定义了两个方法： 一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作，下面的ReentrantReadWriteLock实现了 ReadWriteLock 接口。 ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。 下面通过例子来看一下 ReentrantReadWriteLock 具体用法。 运行结果： 说明 1-5 线程在同时进行读操作。这样就大大提升了读操作的效率。 注意 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。 2.5 小结(重点) Lock和synchronized有以下几点不同： Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现； synchronized发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁； Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断。 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 Lock可以提高多个线程进行读操作的效率。 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远优于synchronized。 三、线程间通信 线程间通信的模型有两种：共享内存和消息传递，一下方法都是基于这两种模型来实现的。我们基于一道面试常见的题目来分析 场景----两个线程对当前数值加1，另一个线程对当前数值减1，要求用线程间通信 3.1 synchronized方案 3.2 Lock 方案 3.3 线程间定制化通信 3.3.1 案例介绍 ==问题: A 线程打印 5 次 A，B 线程打印 10 次 B，C 线程打印 15 次 C,按照 此顺序循环 10 轮== 3.3.2 实现流程 synchronized实现同步的基础：Java中的每一个对象都可以作为锁，具体表现为以下3种形式。 对于普通同步方法，锁对象是当前实例对象。 对应静态同步方法，锁对象是当前类的Class对象 对于同步方法块，锁对象是synchronized括号里配置的对象 四、 集合的线程安全 4.1 集合操作 异常内容：java.util.ConcurrentModificationException 问题: 为什么会出现并发修改异常? 查看 ArrayList 的 add 方法源码 ==如何去解决 List 类型的线程安全问题?== 4.2 Vector Vector 是矢量队列，它是 JDK1.0 版本添加的类。继承于 AbstractList，实现 了 List, RandomAccess, Cloneable 这些接口。 Vector 继承了 AbstractList， 实现了 List；所以，它是一个队列，支持相关的添加、删除、修改、遍历等功能。 Vector 实现了 RandmoAccess 接口，即提供了随机访问功能。 RandmoAccess 是 java 中用来被 List 实现，为 List 提供快速访问功能的。在 Vector 中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访 问。 Vector 实现了 Cloneable 接口，即实现 clone()函数。它能被克隆。 ==和 ArrayList 不同，Vector 中的操作是线程安全的。== 现在没有运行出现并发异常,为什么? add 方法被 synchronized 同步修辞,线程安全!因此没有并发异常 4.3 Collections Collections 提供了方法 synchronizedList 保证 list 是同步线程安全的 没有并发修改异常 查看方法源码 4.4 CopyOnWriteArrayList(重点) 首先我们对CopyOnWriteArrayList进行学习，其特点如下： 它相当于线程安全的ArrayList。和ArrayList一样，它是个可变数组；但是和ArrayList不同的是，它具有以下特性： 它最适合于具有以下特征的应用程序：List大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。 它是线程安全的。 因为通常需要复制整个基础数组，所以可变操作（add()、set()和remove()等待）的开销很大。 迭代器支持hasNext()、next()等不可变操作，但不支持可变的remove()等操作。 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。 1. 独占锁效率低：采用读写分离思想解决 2. 写线程获取到锁，其他写线程阻塞 3. 复制思想： 当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。 这时候会抛出来一个新的问题，也就是数据不一致的问题。如果写线程还没来得及写回内存，其他的线程就会读到了脏数据。 ==这就是 CopyOnWriteArrayList 的思想和原理。就是拷贝一份。== 没有线程安全问题 原因分析(重点):==动态数组与线程安全== 下面从“动态数组”和“线程安全”两个方面进一步对 CopyOnWriteArrayList 的原理进行说明。 “动态数组”机制 它内部有个“volatile数组”（array）来保持数据。在“添加/修改/删除”数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给“volatile数组”，这就是它叫做CopyOnWriteArrayList的原因 由于它再“添加/修改/删除”数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList效率很低；但是单单只是进行遍历查找的话，效率比较高。 \"线程安全\"机制 通过volatile的互斥锁来实现的。 通过“volatile 数组”来保存数据的。一个线程读取 volatile 数组时，总能看到其它线程对该 volatile 变量最后的写入；就这样，通过 volatile 提供了“读取到的数据总是最新的”这个机制的保证。 通过互斥锁来保护数据。在“添加/修改/删除”数据时，会先“获取互斥锁”， 再修改完毕之后，先将数据更新到“volatile 数组”中，然后再“释放互斥锁”，就达到了保护数据的目的。 4.5 小结(重点) 线程安全与线程不安全集合 集合类型中存在线程安全与线程不安全的两种,常见例如: ArrayList ----- Vector HashMap -----HashTable 但是以上都是通过 synchronized 关键字实现,效率较低 Collections 构建的线程安全集合 java.util.concurrent 并发包下 CopyOnWriteArrayList CopyOnWriteArraySet 类型,通过动态数组与线程安 全个方面保证线程安全 五、 多线程锁 5.1 锁的八个问题演示 结论： 一个对象里面如果有多个 synchronized 方法，某一个时刻内，只要一个线程去调用其中的 一个 synchronized 方法了， 其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些 synchronized 方法 锁的是当前对象 this，被锁定后，其它的线程都不能进入到当前对象的其它的 synchronized 方法 加个普通方法后发现和同步锁无关 换成两个对象后，不是同一把锁了，情况立刻变化。 synchronized 实现同步的基础：Java 中的每一个对象都可以作为锁。 具体表现为以下 3 种形式。 对于普通同步方法，锁是当前实例对象。 对于静态同步方法，锁是当前类的 Class 对象。 对于同步方法块，锁是 Synchonized 括号里配置的对象。 当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。 也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁， 可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁， 所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。 所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。 但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！ 六、 Callable&Future接口 6.1 Callable接口 目前我们学习了有两种创建线程的方法：一种通过创建Thread类，另一种是通过使用Runnable创建线程。但是，Runnable缺少的一项功能是，当线程终止时（即run()完成时），我们无法使线程返回结果。为了支持此功能，Java中提供了Callable接口。 ==现在我们学习的是创建线程的第三种方案---Callable接口== Callable接口的特点如下（重点） 为了实现Runnable，需要实现不返回任何内容的run()方法，而对于Callable，需要实现在完成时返回结果的call()方法。 call()方法可以引发异常，而run()则不能。 为了实现Callable而必须重新call方法 不能直接替换runnable，因为Thread类的构造方法根本没有Callable 6.2 Future接口 当call()方法完成时，结果必须存储在主线程已知的对象中，以便主线程可以知道该线程返回的结果。为此，可以使用Future对象。 将Future视为保存结果的对象-它可能暂时不能保存结果，但将来会保存（一旦Callable返回）。Future基本上是主线程可以跟踪进度以及其他线程的结果的一种方式。要实现此接口，必须重新5种方法，这里列出了重要的方法，如下： public boolean cancel（boolean mayInterrupt）：用于停止任务。 ==如果尚未启动，它将停止任务。如果已启动，则仅在 mayInterrupt 为 true 时才会中断任务。== public Object get（）抛出 InterruptedException，ExecutionException： 用于获取任务的结果。 ==如果任务完成，它将立即返回结果，否则将等待任务完成，然后返回结果。== public boolean isDone（）：如果任务完成，则返回 true，否则返回 false 可以看到 Callable 和 Future 做两件事-Callable 与 Runnable 类似，因为它封 装了要在另一个线程上运行的任务，而 Future 用于存储从另一个线程获得的结果。实际上，future 也可以与 Runnable 一起使用。 要创建线程，需要 Runnable。为了获得结果，需要 future。 6.3 FutureTask Java 库具有具体的 FutureTask 类型，该类型实现 Runnable 和 Future，并方便地将两种功能组合在一起。 可以通过为其构造函数提供 Callable 来创建 FutureTask。然后，将 FutureTask 对象提供给 Thread 的构造函数以创建 Thread 对象。因此，间接地使用 Callable 创建线程。 核心原理：(重点) 在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成 当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态 一般FutureTask多用于耗时的计算，主线程可以在 "},"学习资料/Java/Spring注解驱动/Spring注解驱动.html":{"url":"学习资料/Java/Spring注解驱动/Spring注解驱动.html","title":"Spring注解驱动","keywords":"","body":" Spring注解驱动 一、组件注册 1.@Configuration（配置类） 2.@ComponentScan（注解扫描） 3.@Scope（调整作用域） 4.@Lazy（懒加载） 5. @Conditional（按照一定的条件进行判断，满足条件给容器中注册bean） 6.给容器中注册组件 2.AOP原理【看给容器中注册了什么组件，这个组件什么时候工作，这个组件的功能是什么？】 Spring注解驱动 一、组件注册 1.@Configuration（配置类） 告诉Spring这是个配置类 2.@ComponentScan（注解扫描） value：扫描的包路径 includeFilters：参数是一个Filter[]数组，指定扫描的包按照规则包含哪些组件 excludeFilters：参数是一个Filter[]数组，指定扫描的包按照规则排除哪些组件 FilterType.ANNOTATION:按照注释 FilterType.ASSIGNABLE_TYPE：按照给定的类型 FilterType.ASPECTJ:按照ASPECTJ表达式 FilterType.REGEX:使用正则表达式 FilterType.CUSTOM:使用自定义规则，需要实现TypeFilter接口 FilterType.CUSTOM:使用自定义规则 public class MyTypeFilter implements TypeFilter { /** * * @param metadataReader 读取到当前扫描类的信息 * @param metadataReaderFactory 可以获取到其他类信息 * @return * @throws IOException */ @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException { //获取当前类注解信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); //获取当前正在扫描的类信息 ClassMetadata classMetadata = metadataReader.getClassMetadata(); //获取当前类资源（类路径） Resource resource = metadataReader.getResource(); String className = classMetadata.getClassName(); System.out.println(\"---->\"+className); if(className.contains(\"er\")){ return true; } return false; } } 3.@Scope（调整作用域） prototype：多实例的：ioc容器启动并不会去调用方法创建对象在容器中 singleton:单实例的（默认值）：ioc容器启动会调用方法创建对象放在ioc容器中 以后每次获取就直接从容器（map.get()）中拿 request:同一个请求创建一个实例 session:同一个session创建一个实例 4.@Lazy（懒加载） bean 懒加载： 单实例bean：默认在容器启动的时候创建对象 懒加载：容器启动不创建对象。第一次使用（获取）Bean创建对象，并进行一些初始化 5. @Conditional（按照一定的条件进行判断，满足条件给容器中注册bean） 需要实现Condition接口 /** * @Conditional({Condition}):按照一定的条件进行判断，满足条件给容器中注册bean * * 如果系统是windows：给容器注册（“bill”） * 如果系统是linux：给容器注册（“linux”） */ @Conditional({LinuxCondition.class}) @Bean(\"linux\") public Person person02(){ return new Person(\"Linus\",48); /** * 判断是否Linux系统 */ public class LinuxCondition implements Condition { @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) { Environment environment = conditionContext.getEnvironment(); String property = environment.getProperty(\"os.name\"); if(property.contains(\"linux\")){ return true; } return false; } } 6.给容器中注册组件 1）、包扫描+组件标注主机（@Controller/@Service/@Repository/@Component）[局限：自己写的类可以下载，第三方jar包等非自己写的类无法加载] 2）、@Bean[导入的第三方包里面的组件] 3）、@Import[快速给容器中导入一个组件] 1.@Import(要导入到容器中的组件)；容器中就会自动注册这个组件，id默认为全类名 2.ImportSelector:返回需要导入的组件的全类名的数组,需要实现ImportSelector接口； 3.ImportBeanDefinitionRegistrar:手动注册bean到容器中，实现ImportBeanDefinitionRegistrar接口 例如：@Import({Color.class, Red.class, MyImportSelector.class, MyImportBeanDefinitionRegistrar.class})//导入组件，id默认是组件的全类名 /** * 自定义逻辑返回需要导入的组件 */ public class MyImportSelector implements ImportSelector { /** * 返回值就是要导入到容器中组件全类名 * @param annotationMetadata 标注Import注解类的所有注解信息 * @return */ @Override public String[] selectImports(AnnotationMetadata annotationMetadata) { //annotationMetadata.get //方法不用返回null return new String[]{\"com.huahua.bean.Blue\",\"com.huahua.bean.Yellow\"}; } } public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar { /** * * @param annotationMetadata 当前类的注解信息 * @param beanDefinitionRegistry beanDefinition注册类（bean定义注册类） * 把所有需要添加到容器中的bean：调用 * BeanDefinitionRegistry.registerBeanDefinition手工注册 */ @Override public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) { boolean red = beanDefinitionRegistry.containsBeanDefinition(\"com.huahua.bean.Red\"); boolean blue = beanDefinitionRegistry.containsBeanDefinition(\"com.huahua.bean.Blue\"); if (red && blue){ //指定bean定义信息；（Bean类型，Bean...） RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(RainBow.class); //注册一个Bean，指定bean名 beanDefinitionRegistry.registerBeanDefinition(\"rainBow\",rootBeanDefinition); } } } 4）、使用Spring提供的FactoryBean（工厂Bean） 1)、默认获取到的是工厂bean调用getObject创建的对象 2）、要获取工厂Bean本身，我们需要给id前面加一个& 例如：&ColorFactory ```java @Bean public ColorFactoryBean colorFactoryBean(){ return new ColorFactoryBean(); } //创建Spring定义的FactoryBean public class ColorFactoryBean implements FactoryBean { //返回Color对象，这个对象添加到容器中 @Override public Color getObject() throws Exception { System.out.println(\"ColorFactoryBean....\"); return new Color(); } @Override public Class getObjectType() { return Color.class; } /** * 是单例？ * true：这个bean是单实例，在容器中保存一份 * false:多实例，每次获取都会创建一个新的 */ @Override public boolean isSingleton() { return false; } } 二、生命周期 bean的生命周期 bean创建---初始化---销毁的过程 容器管理bean的生命周期： 我们可以自定义初始化和销毁方法：容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法 构造（对象创建） 单实例：在容器启动的时候创建对象 多实例：在每次获取的时候创建对象 BeanPostProcessor.postProcessBeforeInitialization 初始化： 对象创建完成，并赋值好，调用初始化方法... BeanPostProcessor.postProcessAfterInitialization 遍历得到容器中所有的BeanPostProcessors：挨个执行beforeInitialization,一但返回null，跳出for循环，不会执行后面的BeanPostProcessor.postProcessBeforeInitialization(result, beanName); this.populateBean(beanName, mbd, instanceWrapper);给bean进行属性赋值 this.initializeBean{ this.applyBeanPostProcessorsBeforeInitialization(bean, beanName); this.invokeInitMethods(beanName, wrappedBean, mbd);执行初始化 this.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } 销毁： 单实例：容器关闭的时候关闭 多实例：容器不会管理这个bean；容器不会调用销毁方法 1）、指定初始化和销毁方法 指定init-method=\"\" destroy-method=\"\" 2)、通过让Bean实现InitializingBean（定义初始化逻辑）、DisposableBean（定义销毁逻辑） 3)、可以使用JSR250： @PostConstruct:在bean创建完成时完成并且属性赋值完成；来执行初始化方法 @PreDestroy：在容器销毁bean之前通知我们进行清理工作 4）、BeanPostProcessor【interface】：bean的后置处理器 在bean初始化前后进行一些处理工作： postProcessBeforeInitialization：在初始化之前工作 postProcessAfterInitialization：在初始化之后工作 Spring底层对BeanPostProcessor的使用: bean赋值，注入其他组件，@Autowired，生命周期注解功能，@Async，xxx BeanPoseProcessor; 三、AOP 1.AOP简介 AOP：【动态代理】 ​ 指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式。 ①、导入aop模块；Spring AOP; （spring-aspects） ②、定义一个业务逻辑类 (MathCalculator)；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常、xxx） public class MathCalculator { public int div(int i,int j){ return i/j; } } ③、定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行。 通知方法： 前置通知（@Before）：logStart：在目标方法（div）运行之前运行 后置通知（@After）：logEnd：在目标方法（div）运行结束之后运行 返回通知（@AfterReturning）：logReturn：在目标方法（div）正常返回之后运行 异常通知（@AfterThrowing）：logException：在目标方法（div）出现异常以后运行 环绕通知（@Around）：动态代理：手动推进目标方法运行（joinPoint.procced()） @Aspect public class LogAspects { public void logStart(){ System.out.println(\"除法运行。。。。参数列表是：{}\"); } public void logEnd(){ System.out.println(\"除法结束。。。。\"); } public void logReturn(){ System.out.println(\"除法正常返回。。。。运行结果：{}\"); } public void logException(){ System.out.println(\"除法异常。。。。异常信息：{}\"); } } ④、给切面类的目标方法标注方法何时何地运行（通知注解） ⑤、将切面类和业务逻辑类（目标方法所在类）都放入到容器中 ⑥、必须告诉Spring哪个类是切面类（给切面类上加一个注解：@Aspect） ​ @Aspect：告诉Spring当前类是一个切面类 ⑦、给配置类中加@EnableAspectJAutoProxy【开启基于注解的aop模式】 ​ 在Spring中很多的@Enablexxx; 三步： ​ 1）、将业务逻辑组件和切面类都加入到容器中；告诉Spring哪个是切面类（@Aspect） ​ 2）、在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式） ​ 3）、开启基于注解的aop模式@EnableAspectJAutoProxy 2. 2.AOP原理【看给容器中注册了什么组件，这个组件什么时候工作，这个组件的功能是什么？】 @EnableAspectJAutoProxy @Import({AspectJAutoProxyRegistrar.class}) 利用AspectJAutoProxyRegistrar自定义给容器中注册bean: internalAutoProxyCreator=AnnotationAwareAspectJAutoProxyCreator 给容器中注册一个AnnotationAwareAspectJAutoProxyCreator; AnnotationAwareAspectJAutoProxyCreator "},"学习资料/数据库.html":{"url":"学习资料/数据库.html","title":"数据库","keywords":"","body":""},"学习资料/Java/juc并发编程/拓展/管程.html":{"url":"学习资料/Java/juc并发编程/拓展/管程.html","title":"管程深入理解","keywords":"","body":" 管程(Monitor)概念及Java的实现原理 互斥 管程-Monitor 前言 管程(Monitor)概念及Java的实现原理 互斥 互斥访问是并发编程要解决的核心问题之一。 有许多种方法可以满足临界区的互斥访问。大体上可以分为三种， 一种是软件方法，即由用户程序承担互斥访问的责任，而不需要依赖编程语言或操作系统，譬如Dekker算法、Peterson算法等，通常这种方式会有一定的性能开销和编程难度。 第二种是操作系统或编程语言对互斥的原生支持，譬如Linux中的mutex、Java语言的synchronized。 最后是硬件上的特殊指令，譬如著名的CAS。这种方式开销最少，但是很难成为一种通用的解决方案，通常操作系统或编程语言的互斥是基于此建立起来的。 管程-Monitor 前言 "},"学习资料/Java/设计模式/设计模式.html":{"url":"学习资料/Java/设计模式/设计模式.html","title":"设计模式","keywords":"","body":" 设计模式 一、设计模式简介 二、什么是 GOF（四人帮，全拼 Gang of Four）？ 三、设计模式的使用 开发人员的共同平台 最佳的实践 四、设计模式的类型 五、设计模式的七大原则 笔记来源：https://www.runoob.com/design-pattern/design-pattern-tutorial.html 设计模式 一、设计模式简介 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 二、什么是 GOF（四人帮，全拼 Gang of Four）？ 在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。 四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 三、设计模式的使用 设计模式在软件开发中的两个主要用途。 开发人员的共同平台 设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。 最佳的实践 设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。 四、设计模式的类型 根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 序号 模式 & 描述 包括 1 创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern） 2 结构型模式 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern） 3 行为型模式 这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） 4 J2EE 模式 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern） 下面用一个图片来整体描述一下设计模式之间的关系： 五、设计模式的七大原则 1、单一职责原则（Single Responsibility Principle） 2、开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 3、里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 4、依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 5、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 6、迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 7、合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 "},"学习资料/Java/设计模式/创建型模式/创建型模式.html":{"url":"学习资料/Java/设计模式/创建型模式/创建型模式.html","title":"创建型模式","keywords":"","body":"创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） "},"学习资料/Java/设计模式/创建型模式/单例模式.html":{"url":"学习资料/Java/设计模式/创建型模式/单例模式.html","title":"单例模式","keywords":"","body":" 单例模式 一、介绍 二、实现 步骤 1 步骤 2 步骤 3 三、单例模式的几种实现方式 1、懒汉式，线程不安全 2、懒汉式，线程安全 3、饿汉式 4、双检锁/双重校验锁（DCL，即 double-checked locking） 5、登记式/静态内部类 6、枚举 经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。 单例模式 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注意： 1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 一、介绍 意图： 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决： 一个全局使用的类频繁地创建与销毁。 何时使用： 当您想控制实例数目，节省系统资源的时候。 如何解决： 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 关键代码：构造函数是私有的。 应用实例： 1、一个班级只有一个班主任。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。 缺点： 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项： getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化 二、实现 我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。 SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo 类使用 SingleObject 类来获取 SingleObject 对象。 步骤 1 创建一个 Singleton 类。 public class SingleObject { //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject(){} //获取唯一可用的对象 public static SingleObject getInstance(){ return instance; } public void showMessage(){ System.out.println(\"Hello World!\"); } } 步骤 2 从 singleton 类获取唯一的对象。 public class SingletonPatternDemo { public static void main(String[] args) { //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); } } 步骤 3** 执行程序，输出结果： Hello World! 三、单例模式的几种实现方式 单例模式的实现有多种方式，如下所示： 1、懒汉式，线程不安全 是否 Lazy 初始化： 是 是否多线程安全： 否 实现难度： 易 描述： 这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。 这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 2、懒汉式，线程安全 是否 Lazy 初始化： 是 是否多线程安全： 是 实现难度： 易 描述： 这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。 优点：第一次调用才初始化，避免内存浪费。 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。 getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 3、饿汉式 是否 Lazy 初始化： 否 是否多线程安全： 是 实现难度： 易 描述： 这种方式比较常用，但容易产生垃圾对象。 优点：没有加锁，执行效率会提高。 缺点：类加载时就初始化，浪费内存。 它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。 public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } } 4、双检锁/双重校验锁（DCL，即 double-checked locking） JDK 版本： JDK1.5 起 是否 Lazy 初始化： 是 是否多线程安全： 是 实现难度： 较复杂 描述： 这种方式采用双锁机制，安全且在多线程情况下能保持高性能。 getInstance() 的性能对应用程序很关键。 public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 5、登记式/静态内部类 是否 Lazy 初始化： 是 是否多线程安全： 是 实现难度： 一般 描述： 这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。 public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } } 6、枚举 JDK 版本： JDK1.5 起 是否 Lazy 初始化： 否 是否多线程安全： 是 实现难度： 易 描述： 这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。 不能通过 reflection attack 来调用私有构造方法。 public enum Singleton { INSTANCE; public void whateverMethod() { } } 经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。 "},"学习资料/Java/设计模式/创建型模式/工厂模式.html":{"url":"学习资料/Java/设计模式/创建型模式/工厂模式.html","title":"工厂模式","keywords":"","body":" 工厂模式 一、介绍 二、实现 步骤 1 步骤 2 步骤 3 步骤 4 步骤 5 工厂模式 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 一、介绍 意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 主要解决：主要解决接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 关键代码：创建过程在其子类执行。 应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。 优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，\"POP3\"、\"IMAP\"、\"HTTP\"，可以把这三个作为产品类，共同实现一个接口。 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 二、实现 我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。 FactoryPatternDemo 类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。 步骤 1 创建一个接口: public interface Shape { void draw(); } 步骤 2 创建实现接口的实体类。 public class Rectangle implements Shape { @Override public void draw() { System.out.println(\"Inside Rectangle::draw() method.\"); } } public class Square implements Shape { @Override public void draw() { System.out.println(\"Inside Square::draw() method.\"); } } public class Circle implements Shape { @Override public void draw() { System.out.println(\"Inside Circle::draw() method.\"); } } 步骤 3 创建一个工厂，生成基于给定信息的实体类的对象。 public class ShapeFactory { //使用 getShape 方法获取形状类型的对象 public Shape getShape(String shapeType){ if(shapeType == null){ return null; } if(shapeType.equalsIgnoreCase(\"CIRCLE\")){ return new Circle(); } else if(shapeType.equalsIgnoreCase(\"RECTANGLE\")){ return new Rectangle(); } else if(shapeType.equalsIgnoreCase(\"SQUARE\")){ return new Square(); } return null; } } 步骤 4 使用该工厂，通过传递类型信息来获取实体类的对象。 public class FactoryPatternDemo { public static void main(String[] args) { ShapeFactory shapeFactory = new ShapeFactory(); //获取 Circle 的对象，并调用它的 draw 方法 Shape shape1 = shapeFactory.getShape(\"CIRCLE\"); //调用 Circle 的 draw 方法 shape1.draw(); //获取 Rectangle 的对象，并调用它的 draw 方法 Shape shape2 = shapeFactory.getShape(\"RECTANGLE\"); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取 Square 的对象，并调用它的 draw 方法 Shape shape3 = shapeFactory.getShape(\"SQUARE\"); //调用 Square 的 draw 方法 shape3.draw(); } } 步骤 5 执行程序，输出结果： Inside Circle::draw() method. Inside Rectangle::draw() method. Inside Square::draw() method. "},"学习资料/Java/设计模式/创建型模式/抽象工厂模式.html":{"url":"学习资料/Java/设计模式/创建型模式/抽象工厂模式.html","title":"抽象工厂模式","keywords":"","body":" 抽象工厂模式 一、介绍 二、实现 步骤 1 步骤 2 步骤 3 步骤4 步骤 5 步骤 6 步骤 7 步骤 8 步骤 9 三、工厂系列总结 简单工厂模式 工厂模式 抽象工厂模式 抽象工厂模式 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 一、介绍 意图： 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 主要解决： 主要解决接口选择的问题。 何时使用： 系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。 如何解决： 在一个产品族里面，定义多个产品。 关键代码：在一个工厂里聚合多个同类产品。 应用实例： 工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。 优点： 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点： 产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。 使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。 注意事项： 产品族难扩展，产品等级易扩展。 二、实现 我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。 AbstractFactoryPatternDemo 类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。 步骤 1 为形状创建一个接口。 public interface Shape { void draw(); } 步骤 2 创建实现接口的实体类。 public class Rectangle implements Shape { @Override public void draw() { System.out.println(\"Inside Rectangle::draw() method.\"); } } public class Square implements Shape { @Override public void draw() { System.out.println(\"Inside Square::draw() method.\"); } } public class Circle implements Shape { @Override public void draw() { System.out.println(\"Inside Circle::draw() method.\"); } } 步骤 3 为颜色创建一个接口。 public interface Color { void fill(); } 步骤4 创建实现接口的实体类。 public class Red implements Color { @Override public void fill() { System.out.println(\"Inside Red::fill() method.\"); } } public class Green implements Color { @Override public void fill() { System.out.println(\"Inside Green::fill() method.\"); } } public class Blue implements Color { @Override public void fill() { System.out.println(\"Inside Blue::fill() method.\"); } } 步骤 5 为 Color 和 Shape 对象创建抽象类来获取工厂。 public abstract class AbstractFactory { public abstract Color getColor(String color); public abstract Shape getShape(String shape); } 步骤 6 创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。 public class ShapeFactory extends AbstractFactory { @Override public Shape getShape(String shapeType){ if(shapeType == null){ return null; } if(shapeType.equalsIgnoreCase(\"CIRCLE\")){ return new Circle(); } else if(shapeType.equalsIgnoreCase(\"RECTANGLE\")){ return new Rectangle(); } else if(shapeType.equalsIgnoreCase(\"SQUARE\")){ return new Square(); } return null; } @Override public Color getColor(String color) { return null; } } public class ColorFactory extends AbstractFactory { @Override public Shape getShape(String shapeType){ return null; } @Override public Color getColor(String color) { if(color == null){ return null; } if(color.equalsIgnoreCase(\"RED\")){ return new Red(); } else if(color.equalsIgnoreCase(\"GREEN\")){ return new Green(); } else if(color.equalsIgnoreCase(\"BLUE\")){ return new Blue(); } return null; } } 步骤 7 创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。 public class FactoryProducer { public static AbstractFactory getFactory(String choice){ if(choice.equalsIgnoreCase(\"SHAPE\")){ return new ShapeFactory(); } else if(choice.equalsIgnoreCase(\"COLOR\")){ return new ColorFactory(); } return null; } } 步骤 8 使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。 public class AbstractFactoryPatternDemo { public static void main(String[] args) { //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory(\"SHAPE\"); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape(\"CIRCLE\"); //调用 Circle 的 draw 方法 shape1.draw(); //获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape(\"RECTANGLE\"); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape(\"SQUARE\"); //调用 Square 的 draw 方法 shape3.draw(); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory(\"COLOR\"); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor(\"RED\"); //调用 Red 的 fill 方法 color1.fill(); //获取颜色为 Green 的对象 Color color2 = colorFactory.getColor(\"Green\"); //调用 Green 的 fill 方法 color2.fill(); //获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor(\"BLUE\"); //调用 Blue 的 fill 方法 color3.fill(); } } 步骤 9 执行程序，输出结果： Inside Circle::draw() method. Inside Rectangle::draw() method. Inside Square::draw() method. Inside Red::fill() method. Inside Green::fill() method. Inside Blue::fill() method. 三、工厂系列总结 一句话概括工厂模式 简单工厂：一个工厂类，一个产品抽象类。 工厂方法：多个工厂类，一个产品抽象类。 抽象工厂：多个工厂类，多个产品抽象类。 生活中的工厂模式 简单工厂类：一个麦当劳店，可以生产多种汉堡。 工厂方法类：一个麦当劳店，可以生产多种汉堡。一个肯德基店，也可以生产多种汉堡。 抽象工厂类：百胜餐饮集团下有肯德基和百事公司，肯德基生产汉堡，百事公司生成百事可乐。 下面例子中鼠标，键盘，耳麦为产品，惠普，戴尔为工厂。 简单工厂模式 简单工厂模式不是 23 种里的一种，简而言之，就是有一个专门生产某个产品的类。 比如下图中的鼠标工厂，专业生产鼠标，给参数 0，生产戴尔鼠标，给参数 1，生产惠普鼠标。 工厂模式 工厂模式也就是鼠标工厂是个父类，有生产鼠标这个接口。 戴尔鼠标工厂，惠普鼠标工厂继承它，可以分别生产戴尔鼠标，惠普鼠标。 生产哪种鼠标不再由参数决定，而是创建鼠标工厂时，由戴尔鼠标工厂创建。 后续直接调用鼠标工厂.生产鼠标()即可 抽象工厂模式 抽象工厂模式也就是不仅生产鼠标，同时生产键盘。 也就是 PC 厂商是个父类，有生产鼠标，生产键盘两个接口。 戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。 创建工厂时，由戴尔工厂创建。 后续工厂.生产鼠标()则生产戴尔鼠标，工厂.生产键盘()则生产戴尔键盘。 在抽象工厂模式中，假设我们需要增加一个工厂 假设我们增加华硕工厂，则我们需要增加华硕工厂，和戴尔工厂一样，继承 PC 厂商。 之后创建华硕鼠标，继承鼠标类。创建华硕键盘，继承键盘类即可。 在抽象工厂模式中，假设我们需要增加一个产品 假设我们增加耳麦这个产品，则首先我们需要增加耳麦这个父类，再加上戴尔耳麦，惠普耳麦这两个子类。 之后在PC厂商这个父类中，增加生产耳麦的接口。最后在戴尔工厂，惠普工厂这两个类中，分别实现生产戴尔耳麦，惠普耳麦的功能。 以上。 "},"学习资料/Java/设计模式/创建型模式/建造者模式.html":{"url":"学习资料/Java/设计模式/创建型模式/建造者模式.html","title":"建造者模式","keywords":"","body":" 建造者模式 一、介绍 二、实现 步骤 1 步骤 2 步骤 3 步骤 4 步骤 5 步骤 6 步骤 7 步骤 8 建造者模式 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。 一、介绍 意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 主要解决：主要解决在软件系统中，有时候面临着\"一个复杂对象\"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 何时使用：一些基本部件不会变，而其组合经常变化的时候。 如何解决：将变与不变分离开。 关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。 应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的\"套餐\"。 2、JAVA 中的 StringBuilder。 优点： 1、建造者独立，易扩展。 2、便于控制细节风险。 缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。 使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。 注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。 二、实现 我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。 我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。 然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo 类使用 MealBuilder 来创建一个 Meal。 步骤 1 创建一个表示食物条目和食物包装的接口。 public interface Item { public String name(); public Packing packing(); public float price(); } public interface Packing { public String pack(); } 步骤 2 创建实现 Packing 接口的实体类。 public class Wrapper implements Packing { @Override public String pack() { return \"Wrapper\"; } } public class Bottle implements Packing { @Override public String pack() { return \"Bottle\"; } } 步骤 3 创建实现 Item 接口的抽象类，该类提供了默认的功能。 public abstract class Burger implements Item { @Override public Packing packing() { return new Wrapper(); } @Override public abstract float price(); } public abstract class ColdDrink implements Item { @Override public Packing packing() { return new Bottle(); } @Override public abstract float price(); } 步骤 4 创建扩展了 Burger 和 ColdDrink 的实体类。 public class VegBurger extends Burger { @Override public float price() { return 25.0f; } @Override public String name() { return \"Veg Burger\"; } } public class ChickenBurger extends Burger { @Override public float price() { return 50.5f; } @Override public String name() { return \"Chicken Burger\"; } } public class Coke extends ColdDrink { @Override public float price() { return 30.0f; } @Override public String name() { return \"Coke\"; } } public class Pepsi extends ColdDrink { @Override public float price() { return 35.0f; } @Override public String name() { return \"Pepsi\"; } } 步骤 5 创建一个 Meal 类，带有上面定义的 Item 对象。 import java.util.ArrayList; import java.util.List; public class Meal { private List items = new ArrayList(); public void addItem(Item item){ items.add(item); } public float getCost(){ float cost = 0.0f; for (Item item : items) { cost += item.price(); } return cost; } public void showItems(){ for (Item item : items) { System.out.print(\"Item : \"+item.name()); System.out.print(\", Packing : \"+item.packing().pack()); System.out.println(\", Price : \"+item.price()); } } } 步骤 6 创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。 public class MealBuilder { public Meal prepareVegMeal (){ Meal meal = new Meal(); meal.addItem(new VegBurger()); meal.addItem(new Coke()); return meal; } public Meal prepareNonVegMeal (){ Meal meal = new Meal(); meal.addItem(new ChickenBurger()); meal.addItem(new Pepsi()); return meal; } } 步骤 7 BuiderPatternDemo 使用 MealBuilder 来演示建造者模式（Builder Pattern）。 public class BuilderPatternDemo { public static void main(String[] args) { MealBuilder mealBuilder = new MealBuilder(); Meal vegMeal = mealBuilder.prepareVegMeal(); System.out.println(\"Veg Meal\"); vegMeal.showItems(); System.out.println(\"Total Cost: \" +vegMeal.getCost()); Meal nonVegMeal = mealBuilder.prepareNonVegMeal(); System.out.println(\"\\n\\nNon-Veg Meal\"); nonVegMeal.showItems(); System.out.println(\"Total Cost: \" +nonVegMeal.getCost()); } } 步骤 8 执行程序，输出结果： Veg Meal Item : Veg Burger, Packing : Wrapper, Price : 25.0 Item : Coke, Packing : Bottle, Price : 30.0 Total Cost: 55.0 Non-Veg Meal Item : Chicken Burger, Packing : Wrapper, Price : 50.5 Item : Pepsi, Packing : Bottle, Price : 35.0 Total Cost: 85.5 "},"学习资料/Java/设计模式/创建型模式/原型模式.html":{"url":"学习资料/Java/设计模式/创建型模式/原型模式.html","title":"原型模式","keywords":"","body":" 原型模式 一、介绍 二、实现 步骤 1 步骤 2 步骤 3 步骤 4 步骤 5 原型模式 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。 一、介绍 意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 主要解决：在运行期建立和删除原型。 何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。 关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些\"易变类\"拥有稳定的接口。 应用实例： 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。 优点： 1、性能提高。 2、逃避构造函数的约束。 缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。 使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。 注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。 二、实现 我们将创建一个抽象类 Shape 和扩展了 Shape 类的实体类。下一步是定义类 ShapeCache，该类把 shape 对象存储在一个 Hashtable 中，并在请求的时候返回它们的克隆。 PrototypePatternDemo 类使用 ShapeCache 类来获取 Shape 对象。 步骤 1 创建一个实现了 Cloneable 接口的抽象类。 public abstract class Shape implements Cloneable { private String id; protected String type; abstract void draw(); public String getType(){ return type; } public String getId() { return id; } public void setId(String id) { this.id = id; } public Object clone() { Object clone = null; try { clone = super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return clone; } } 步骤 2 创建扩展了上面抽象类的实体类。 public class Rectangle extends Shape { public Rectangle(){ type = \"Rectangle\"; } @Override public void draw() { System.out.println(\"Inside Rectangle::draw() method.\"); } } public class Square extends Shape { public Square(){ type = \"Square\"; } @Override public void draw() { System.out.println(\"Inside Square::draw() method.\"); } } public class Circle extends Shape { public Circle(){ type = \"Circle\"; } @Override public void draw() { System.out.println(\"Inside Circle::draw() method.\"); } } 步骤 3 创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中。 import java.util.Hashtable; public class ShapeCache { private static Hashtable shapeMap = new Hashtable(); public static Shape getShape(String shapeId) { Shape cachedShape = shapeMap.get(shapeId); return (Shape) cachedShape.clone(); } // 对每种形状都运行数据库查询，并创建该形状 // shapeMap.put(shapeKey, shape); // 例如，我们要添加三种形状 public static void loadCache() { System.out.println(\"loadCache start.....\"); Circle circle = new Circle(); circle.setId(\"1\"); shapeMap.put(circle.getId(),circle); System.out.println(\"loadCache Circle:\" + circle); Square square = new Square(); square.setId(\"2\"); shapeMap.put(square.getId(),square); System.out.println(\"loadCache Square:\" + square); Rectangle rectangle = new Rectangle(); rectangle.setId(\"3\"); shapeMap.put(rectangle.getId(),rectangle); System.out.println(\"loadCache Rectangle:\" + rectangle); System.out.println(\"loadCache stop.....\"); } } 步骤 4 PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆。 public class PrototypePatternDemo { public static void main(String[] args) { ShapeCache.loadCache(); Shape clonedShape = (Shape) ShapeCache.getShape(\"1\"); System.out.println(\"Shape : \" + clonedShape + \"====\" + clonedShape.getType()); Shape clonedShape2 = (Shape) ShapeCache.getShape(\"2\"); System.out.println(\"Shape : \" + clonedShape2 + \"====\" + clonedShape2.getType()); Shape clonedShape3 = (Shape) ShapeCache.getShape(\"3\"); System.out.println(\"Shape : \" + clonedShape3 + \"====\" + clonedShape3.getType()); Shape clonedShape4 = (Shape) ShapeCache.getShape(\"1\"); System.out.println(\"Shape : \" + clonedShape4 + \"====\" + clonedShape4.getType()); Shape clonedShape5 = (Shape) ShapeCache.getShape(\"2\"); System.out.println(\"Shape : \" + clonedShape5 + \"====\" + clonedShape5.getType()); Shape clonedShape6 = (Shape) ShapeCache.getShape(\"3\"); System.out.println(\"Shape : \" + clonedShape6 + \"====\" + clonedShape6.getType()); } } 步骤 5 执行程序，输出结果： loadCache start..... loadCache Circle:com.huahua.test.clone.Circle@511d50c0 loadCache Square:com.huahua.test.clone.Square@60e53b93 loadCache Rectangle:com.huahua.test.clone.Rectangle@5e2de80c loadCache stop..... Shape : com.huahua.test.clone.Circle@1d44bcfa====Circle Shape : com.huahua.test.clone.Square@266474c2====Square Shape : com.huahua.test.clone.Rectangle@6f94fa3e====Rectangle Shape : com.huahua.test.clone.Circle@5e481248====Circle Shape : com.huahua.test.clone.Square@66d3c617====Square Shape : com.huahua.test.clone.Rectangle@63947c6b====Rectangle "},"学习资料/Java/设计模式/结构型模式/结构型模式.html":{"url":"学习资料/Java/设计模式/结构型模式/结构型模式.html","title":"结构型模式","keywords":"","body":"结构型模式 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） "},"学习资料/Java/设计模式/结构型模式/外观模式.html":{"url":"学习资料/Java/设计模式/结构型模式/外观模式.html","title":"外观模式","keywords":"","body":" 外观模式 一、介绍 二、实现 步骤 1 步骤 2 步骤 3 步骤 4 步骤 5 外观模式 外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。 这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。 一、介绍 意图： 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 主要解决： 降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。 何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个\"接待员\"即可。 2、定义系统的入口。 如何解决： 客户端不与系统耦合，外观类与系统耦合。 关键代码： 在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。 应用实例： 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。 优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。 缺点： 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。 使用场景： 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。 注意事项： 在层次化结构中，可以使用外观模式定义系统中每一层的入口。 二、实现 我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。下一步是定义一个外观类 ShapeMaker。 ShapeMaker 类使用实体类来代表用户对这些类的调用。FacadePatternDemo 类使用 ShapeMaker 类来显示结果。 步骤 1 创建一个接口。 public interface Shape { void draw(); } 步骤 2 创建实现接口的实体类。 public class Rectangle implements Shape { @Override public void draw() { System.out.println(\"Rectangle::draw()\"); } } public class Square implements Shape { @Override public void draw() { System.out.println(\"Square::draw()\"); } } public class Circle implements Shape { @Override public void draw() { System.out.println(\"Circle::draw()\"); } } 步骤 3 创建一个外观类。 public class ShapeMaker { private Shape circle; private Shape rectangle; private Shape square; public ShapeMaker() { circle = new Circle(); rectangle = new Rectangle(); square = new Square(); } public void drawCircle(){ circle.draw(); } public void drawRectangle(){ rectangle.draw(); } public void drawSquare(){ square.draw(); } } 步骤 4 使用该外观类画出各种类型的形状。 public class FacadePatternDemo { public static void main(String[] args) { ShapeMaker shapeMaker = new ShapeMaker(); shapeMaker.drawCircle(); shapeMaker.drawRectangle(); shapeMaker.drawSquare(); } } 步骤 5 执行程序，输出结果： Circle::draw() Rectangle::draw() Square::draw() "},"学习资料/Java/设计模式/结构型模式/装饰器模式.html":{"url":"学习资料/Java/设计模式/结构型模式/装饰器模式.html","title":"装饰器模式","keywords":"","body":" 装饰器模式 一、介绍 二、实现 步骤 1 步骤 2 步骤 3 步骤 4 步骤 5 步骤 6 装饰器模式 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。 一、介绍 意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。 主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。 何时使用：在不想增加很多子类的情况下扩展类。 如何解决：将具体功能职责划分，同时继承装饰者模式。 关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。 应用实例： 1、孙悟空有 72 变，当他变成\"庙宇\"后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 缺点：多层装饰比较复杂。 使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。 注意事项：可代替继承。 二、实现 我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。 RedShapeDecorator 是实现了 ShapeDecorator 的实体类。 DecoratorPatternDemo 类使用 RedShapeDecorator 来装饰 Shape 对象。 步骤 1 public interface Shape { void draw(); } 步骤 2 public class Rectangle implements Shape { @Override public void draw() { System.out.println(\"Shape: Rectangle\"); } } public class Circle implements Shape { @Override public void draw() { System.out.println(\"Shape: Circle\"); } } 步骤 3 创建实现了 Shape 接口的抽象装饰类。 public abstract class ShapeDecorator implements Shape { protected Shape decoratedShape; public ShapeDecorator(Shape decoratedShape){ this.decoratedShape = decoratedShape; } public void draw(){ decoratedShape.draw(); } } 步骤 4 创建扩展了 ShapeDecorator 类的实体装饰类。 public class RedShapeDecorator extends ShapeDecorator { public RedShapeDecorator(Shape decoratedShape) { super(decoratedShape); } @Override public void draw() { decoratedShape.draw(); setRedBorder(decoratedShape); } private void setRedBorder(Shape decoratedShape){ System.out.println(\"Border Color: Red\"); } } 步骤 5 使用 RedShapeDecorator 来装饰 Shape 对象。 public class DecoratorPatternDemo { public static void main(String[] args) { Shape circle = new Circle(); ShapeDecorator redCircle = new RedShapeDecorator(new Circle()); ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle()); //Shape redCircle = new RedShapeDecorator(new Circle()); //Shape redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println(\"Circle with normal border\"); circle.draw(); System.out.println(\"\\nCircle of red border\"); redCircle.draw(); System.out.println(\"\\nRectangle of red border\"); redRectangle.draw(); } } 步骤 6 执行程序，输出结果： Circle with normal border Shape: Circle Circle of red border Shape: Circle Border Color: Red Rectangle of red border Shape: Rectangle Border Color: Red "},"学习资料/Java/设计模式/结构型模式/组合模式.html":{"url":"学习资料/Java/设计模式/结构型模式/组合模式.html","title":"组合模式","keywords":"","body":" 组合模式 一、介绍 二、实现 步骤 1 步骤 2 步骤 3 组合模式 组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。 这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。 我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。 一、介绍 意图：将对象组合成树形结构以表示\"部分-整体\"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。 何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。 关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。 应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。 优点： 1、高层模块调用简单。 2、节点自由增加。 缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。 使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。 注意事项：定义时为具体类。 二、实现 我们有一个类 Employee，该类被当作组合模型类。CompositePatternDemo 类使用 Employee 类来添加部门层次结构，并打印所有员工。 步骤 1 创建 Employee 类，该类带有 Employee 对象的列表。 import java.util.ArrayList; import java.util.List; public class Employee { private String name; private String dept; private int salary; private List subordinates; //构造函数 public Employee(String name,String dept, int sal) { this.name = name; this.dept = dept; this.salary = sal; subordinates = new ArrayList(); } public void add(Employee e) { subordinates.add(e); } public void remove(Employee e) { subordinates.remove(e); } public List getSubordinates(){ return subordinates; } public String toString(){ return (\"Employee :[ Name : \"+ name +\", dept : \"+ dept + \", salary :\" + salary+\" ]\"); } } 步骤 2 使用 Employee 类来创建和打印员工的层次结构。 public class CompositePatternDemo { public static void main(String[] args) { Employee CEO = new Employee(\"John\",\"CEO\", 30000); Employee headSales = new Employee(\"Robert\",\"Head Sales\", 20000); Employee headMarketing = new Employee(\"Michel\",\"Head Marketing\", 20000); Employee clerk1 = new Employee(\"Laura\",\"Marketing\", 10000); Employee clerk2 = new Employee(\"Bob\",\"Marketing\", 10000); Employee salesExecutive1 = new Employee(\"Richard\",\"Sales\", 10000); Employee salesExecutive2 = new Employee(\"Rob\",\"Sales\", 10000); CEO.add(headSales); CEO.add(headMarketing); headSales.add(salesExecutive1); headSales.add(salesExecutive2); headMarketing.add(clerk1); headMarketing.add(clerk2); //打印该组织的所有员工 System.out.println(CEO); for (Employee headEmployee : CEO.getSubordinates()) { System.out.println(headEmployee); for (Employee employee : headEmployee.getSubordinates()) { System.out.println(employee); } } } } 步骤 3 执行程序，输出结果为： Employee :[ Name : John, dept : CEO, salary :30000 ] Employee :[ Name : Robert, dept : Head Sales, salary :20000 ] Employee :[ Name : Richard, dept : Sales, salary :10000 ] Employee :[ Name : Rob, dept : Sales, salary :10000 ] Employee :[ Name : Michel, dept : Head Marketing, salary :20000 ] Employee :[ Name : Laura, dept : Marketing, salary :10000 ] Employee :[ Name : Bob, dept : Marketing, salary :10000 ] "},"学习资料/Java/设计模式/结构型模式/享元模式.html":{"url":"学习资料/Java/设计模式/结构型模式/享元模式.html","title":"享元模式","keywords":"","body":" 享元模式 一、介绍 二、实现 步骤 1 步骤 2 步骤 3 步骤 4 步骤 5 享元模式 享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。 一、介绍 意图：运用共享技术有效地支持大量细粒度的对象。 主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。 何时使用： 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。 如何解决：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。 关键代码：用 HashMap 存储这些对象。 应用实例： 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。 优点：大大减少对象的创建，降低系统的内存，使效率提高。 缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。 使用场景： 1、系统有大量相似对象。 2、需要缓冲池的场景。 注意事项： 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。 二、实现 我们将创建一个 Shape 接口和实现了 Shape 接口的实体类 Circle。下一步是定义工厂类 ShapeFactory。 ShapeFactory 有一个 Circle 的 HashMap，其中键名为 Circle 对象的颜色。无论何时接收到请求，都会创建一个特定颜色的圆。ShapeFactory 检查它的 HashMap 中的 circle 对象，如果找到 Circle 对象，则返回该对象，否则将创建一个存储在 hashmap 中以备后续使用的新对象，并把该对象返回到客户端。 FlyWeightPatternDemo 类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（red / green / blue/ black / white），以便获取它所需对象的颜色。 步骤 1 创建一个接口。 public interface Shape { void draw(); } 步骤 2 创建实现接口的实体类。 public class Circle implements Shape { private String color; private int x; private int y; private int radius; public Circle(String color){ this.color = color; } public void setX(int x) { this.x = x; } public void setY(int y) { this.y = y; } public void setRadius(int radius) { this.radius = radius; } @Override public void draw() { System.out.println(\"Circle: Draw() [Color : \" + color +\", x : \" + x +\", y :\" + y +\", radius :\" + radius); } } 步骤 3 创建一个工厂，生成基于给定信息的实体类的对象。 import java.util.HashMap; public class ShapeFactory { private static final HashMap circleMap = new HashMap<>(); public static Shape getCircle(String color) { Circle circle = (Circle)circleMap.get(color); if(circle == null) { circle = new Circle(color); circleMap.put(color, circle); System.out.println(\"Creating circle of color : \" + color); } return circle; } } 步骤 4 使用该工厂，通过传递颜色信息来获取实体类的对象。 public class FlyweightPatternDemo { private static final String colors[] = { \"Red\", \"Green\", \"Blue\", \"White\", \"Black\" }; public static void main(String[] args) { for(int i=0; i 步骤 5 执行程序，输出结果： Creating circle of color : Black Circle: Draw() [Color : Black, x : 36, y :71, radius :100 Creating circle of color : Green Circle: Draw() [Color : Green, x : 27, y :27, radius :100 Creating circle of color : White Circle: Draw() [Color : White, x : 64, y :10, radius :100 Creating circle of color : Red Circle: Draw() [Color : Red, x : 15, y :44, radius :100 Circle: Draw() [Color : Green, x : 19, y :10, radius :100 Circle: Draw() [Color : Green, x : 94, y :32, radius :100 Circle: Draw() [Color : White, x : 69, y :98, radius :100 Creating circle of color : Blue Circle: Draw() [Color : Blue, x : 13, y :4, radius :100 Circle: Draw() [Color : Green, x : 21, y :21, radius :100 Circle: Draw() [Color : Blue, x : 55, y :86, radius :100 Circle: Draw() [Color : White, x : 90, y :70, radius :100 Circle: Draw() [Color : Green, x : 78, y :3, radius :100 Circle: Draw() [Color : Green, x : 64, y :89, radius :100 Circle: Draw() [Color : Blue, x : 3, y :91, radius :100 Circle: Draw() [Color : Blue, x : 62, y :82, radius :100 Circle: Draw() [Color : Green, x : 97, y :61, radius :100 Circle: Draw() [Color : Green, x : 86, y :12, radius :100 Circle: Draw() [Color : Green, x : 38, y :93, radius :100 Circle: Draw() [Color : Red, x : 76, y :82, radius :100 Circle: Draw() [Color : Blue, x : 95, y :82, radius :100 "},"学习资料/Java/设计模式/结构型模式/代理模式.html":{"url":"学习资料/Java/设计模式/结构型模式/代理模式.html","title":"代理模式","keywords":"","body":" 代理模式 一、介绍 二、实现（静态代理） 步骤 1 步骤 2 步骤 3 步骤 4 步骤 5 三、实现（动态代理） 步骤 1 步骤 2 步骤 3 步骤 4 四、静态代理模式和装饰器模式区别 总结 五.【继承】、【装饰者模式】、【动态代理模式】之间的比较 代理模式 在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。 在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 一、介绍 意图：为其他对象提供一种代理以控制对这个对象的访问。 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 何时使用：想在访问一个类时做一些控制。 如何解决：增加中间层。 关键代码：实现与被代理类组合。 应用实例： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。 优点： 1、职责清晰。 2、高扩展性。 3、智能化。 缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 使用场景：按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。 注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 二、实现（静态代理） 我们将创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。 ProxyPatternDemo 类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。 步骤 1 创建一个接口。 public interface Image { void display(); } 步骤 2 创建实现接口的实体类。 public class RealImage implements Image { private String fileName; public RealImage(String fileName){ this.fileName = fileName; loadFromDisk(fileName); } @Override public void display() { System.out.println(\"Displaying \" + fileName); } private void loadFromDisk(String fileName){ System.out.println(\"Loading \" + fileName); } } 步骤 3 创建实现接口的实体类的静态代理类。 public class ProxyImage implements Image{ private RealImage realImage; private String fileName; public ProxyImage(String fileName){ this.fileName = fileName; } @Override public void display() { if(realImage == null){ realImage = new RealImage(fileName); } //代理前操作 System.out.println(\"display before....\"); realImage.display(); //代理后操作 System.out.println(\"display after....\"); } } 步骤 4 当被请求时，使用 ProxyImage 来获取 RealImage 类的对象。 public class ProxyPatternDemo { public static void main(String[] args) { Image image = new ProxyImage(\"test_10mb.jpg\"); // 图像将从磁盘加载 image.display(); System.out.println(\"\"); // 图像不需要从磁盘加载 image.display(); } } 步骤 5 执行程序，输出结果： Loading test_10mb.jpg display before.... Displaying test_10mb.jpg display after.... display before.... Displaying test_10mb.jpg display after.... 三、实现（动态代理） 步骤 1 创建一个接口。 public interface Image { void display(); } 步骤 2 创建实现接口的实体类。 public class RealImage implements Image { private String fileName; public RealImage(String fileName){ this.fileName = fileName; loadFromDisk(fileName); } @Override public void display() { System.out.println(\"Displaying \" + fileName); } private void loadFromDisk(String fileName){ System.out.println(\"Loading \" + fileName); } } 步骤 3 当被请求时，使用 动态代理 来调用 RealImage 类的对象。 public class ProxyPatternDemo { public static void main(String[] args) { //Proxy实现----代理类需要有接口 Image imageProxy = (Image) Proxy.newProxyInstance(RealImage.class.getClassLoader(), new Class[]{Image.class}, new InvocationHandler() { private Image image = new RealImage(\"test_11mb.jpg\"); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"display before....\"); Object o = method.invoke(image, args); System.out.println(\"display after....\"); return o; } }); imageProxy.display(); System.out.println(\"\"); imageProxy.display(); //cglib实现----代理类不需要有接口 // Enhancer enhancer = new Enhancer(); // enhancer.setSuperclass(RealImage.class); // enhancer.setCallback(new MethodInterceptor() { // @Override // public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { // System.out.println(\"display before....\"); // Object result = methodProxy.invokeSuper(o, objects); // System.out.println(\"display after....\"); // return result; // } // }); // RealImage o = (RealImage) enhancer.create(new Class[]{String.class},new Object[]{\"test_12mb.jpg\"}); // o.display(); // System.out.println(); // o.display(); } } 步骤 4 执行程序，输出结果： //Proxy实现 Loading test_11mb.jpg display before.... Displaying test_11mb.jpg display after.... display before.... Displaying test_11mb.jpg display after.... //cglib实现 //Loading test_11mb.jpg //display before.... //Displaying test_11mb.jpg //display after.... //display before.... //Displaying test_11mb.jpg //display after.... 四、静态代理模式和装饰器模式区别 对装饰器模式来说，装饰者（Decorator）和被装饰者（Decoratee）都实现一个接口。对代理模式来说，代理类（Proxy Class）和真实处理的类（Real Class）都实现同一个接口。此外，不论我们使用哪一个模式，都可以很容易地在真实对象的方法前面或者后面加上自定义的方法。 在上面的例子中，装饰器模式是使用的调用者从外部传入的被装饰对象（coffee），调用者只想要你把他给你的对象装饰（加强）一下。而代理模式使用的是代理对象在自己的构造方法里面new的一个被代理的对象，不是调用者传入的。调用者不知道你找了其他人，他也不关心这些事，只要你把事情做对了即可。 装饰器模式关注于在一个对象上动态地添加方法，而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类可以对它的客户隐藏一个对象的具体信息。因此当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例；当使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰器的构造器。 装饰器模式和代理模式的使用场景不一样，比如IO流使用的是装饰者模式，可以层层增加功能。而代理模式则一般是用于增加特殊的功能，有些动态代理不支持多层嵌套。 代理和装饰其实从另一个角度更容易去理解两个模式的区别：代理更多的是强调对对象的访问控制，比如说，访问A对象的查询功能时，访问B对象的更新功能时，访问C对象的删除功能时，都需要判断对象是否登陆，那么我需要将判断用户是否登陆的功能抽提出来，并对A对象、B对象和C对象进行代理，使访问它们时都需要去判断用户是否登陆，简单地说就是将某个控制访问权限应用到多个对象上；而装饰器更多的强调给对象加强功能，比如说要给只会唱歌的A对象添加跳舞功能，添加说唱功能等，简单地说就是将多个功能附加在一个对象上。 所以，代理模式注重的是对对象的某一功能的流程把控和辅助，它可以控制对象做某些事，重心是为了借用对象的功能完成某一流程，而非对象功能如何。而装饰模式注重的是对对象功能的扩展，不关心外界如何调用，只注重对对象功能加强，装饰后还是对象本身。 总结 对于代理类，如何调用对象的某一功能是思考重点，而不需要兼顾对象的所有功能；对于装饰类，如何扩展对象的某一功能是思考重点，同时也需要兼顾对象的其他功能，因为再怎么装饰，本质也是对象本身，要担负起对象应有的职责，被装饰者的职责一旦增加，作为装饰类也需要有相应的扩展，必然会造成编码的负担。 设计模式本身是为了提升代码的可扩展性，灵活应用即可，不必生搬硬套，非要分出个所以然来，装饰器模式和代理模式的区别也是如此。 五.【继承】、【装饰者模式】、【动态代理模式】之间的比较 继承 装饰者模式 动态代理模式 作用 增加功能（给x添加y功能） 增加功能（给x添加y功能） 增加功能（给x添加y功能） 优点 x可变 x和y都可变 缺点 x和y都不可变 y不可变 灵活性 低 中 高 参考文档： 装饰器模式和代理模式的区别 对象的功能扩展方式（继承、装饰者设计模式、动态代理设计模式） "},"学习资料/Java/设计模式/结构型模式/适配器模式.html":{"url":"学习资料/Java/设计模式/结构型模式/适配器模式.html","title":"适配器模式","keywords":"","body":" 适配器模式 一、介绍 二、实现 步骤 1 步骤 2 步骤 3 步骤 4 步骤 5 步骤 6 适配器模式 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。 一、介绍 意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 主要解决：主要解决在软件系统中，常常要将一些\"现存的对象\"放到新的环境中，而新环境要求的接口是现对象不能满足的。 何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。） 如何解决：继承或依赖（推荐）。 关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。 应用实例： 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。 优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。 缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。 使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。 注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。 二、实现 我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。 我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。 我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。 AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo 类使用 AudioPlayer 类来播放各种格式。 步骤 1 为媒体播放器和更高级的媒体播放器创建接口。 public interface MediaPlayer { public void play(String audioType, String fileName); } public interface AdvancedMediaPlayer { public void playVlc(String fileName); public void playMp4(String fileName); } 步骤 2 创建实现了 AdvancedMediaPlayer 接口的实体类。 public class VlcPlayer implements AdvancedMediaPlayer{ @Override public void playVlc(String fileName) { System.out.println(\"Playing vlc file. Name: \"+ fileName); } @Override public void playMp4(String fileName) { //什么也不做 } } public class Mp4Player implements AdvancedMediaPlayer{ @Override public void playVlc(String fileName) { //什么也不做 } @Override public void playMp4(String fileName) { System.out.println(\"Playing mp4 file. Name: \"+ fileName); } } 步骤 3 创建实现了 MediaPlayer 接口的适配器类。 public class MediaAdapter implements MediaPlayer { AdvancedMediaPlayer advancedMusicPlayer; public MediaAdapter(String audioType){ if(audioType.equalsIgnoreCase(\"vlc\") ){ advancedMusicPlayer = new VlcPlayer(); } else if (audioType.equalsIgnoreCase(\"mp4\")){ advancedMusicPlayer = new Mp4Player(); } } @Override public void play(String audioType, String fileName) { if(audioType.equalsIgnoreCase(\"vlc\")){ advancedMusicPlayer.playVlc(fileName); }else if(audioType.equalsIgnoreCase(\"mp4\")){ advancedMusicPlayer.playMp4(fileName); } } } 步骤 4 创建实现了 MediaPlayer 接口的实体类。 public class AudioPlayer implements MediaPlayer { MediaAdapter mediaAdapter; @Override public void play(String audioType, String fileName) { //播放 mp3 音乐文件的内置支持 if(audioType.equalsIgnoreCase(\"mp3\")){ System.out.println(\"Playing mp3 file. Name: \"+ fileName); } //mediaAdapter 提供了播放其他文件格式的支持 else if(audioType.equalsIgnoreCase(\"vlc\") || audioType.equalsIgnoreCase(\"mp4\")){ mediaAdapter = new MediaAdapter(audioType); mediaAdapter.play(audioType, fileName); } else{ System.out.println(\"Invalid media. \"+ audioType + \" format not supported\"); } } } 步骤 5 使用 AudioPlayer 来播放不同类型的音频格式。 public class AdapterPatternDemo { public static void main(String[] args) { AudioPlayer audioPlayer = new AudioPlayer(); audioPlayer.play(\"mp3\", \"beyond the horizon.mp3\"); audioPlayer.play(\"mp4\", \"alone.mp4\"); audioPlayer.play(\"vlc\", \"far far away.vlc\"); audioPlayer.play(\"avi\", \"mind me.avi\"); } } 步骤 6 执行程序，输出结果： Playing mp3 file. Name: beyond the horizon.mp3 Playing mp4 file. Name: alone.mp4 Playing vlc file. Name: far far away.vlc Invalid media. avi format not supported "},"学习资料/Java/设计模式/结构型模式/桥接模式.html":{"url":"学习资料/Java/设计模式/结构型模式/桥接模式.html","title":"桥接模式","keywords":"","body":" 桥接模式 一、介绍 二、实现 步骤 1 步骤 2 步骤 3 步骤 4 步骤 5 步骤 6 桥接模式 桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。 这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。 我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。 一、介绍 意图：将抽象部分与实现部分分离，使它们都可以独立的变化。 主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。 何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。 如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。 关键代码：抽象类依赖实现类。 应用实例： 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。 优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。 缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 使用场景： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。 二、实现 我们有一个作为桥接实现的 DrawAPI 接口和实现了 DrawAPI 接口的实体类 RedCircle、GreenCircle。Shape 是一个抽象类，将使用 DrawAPI 的对象。BridgePatternDemo 类使用 Shape 类来画出不同颜色的圆。 步骤 1 创建桥接实现接口。 public interface DrawAPI { public void drawCircle(int radius, int x, int y); } 步骤 2 创建实现了 DrawAPI 接口的实体桥接实现类。 public class RedCircle implements DrawAPI { @Override public void drawCircle(int radius, int x, int y) { System.out.println(\"Drawing Circle[ color: red, radius: \" + radius +\", x: \" +x+\", \"+ y +\"]\"); } } public class GreenCircle implements DrawAPI { @Override public void drawCircle(int radius, int x, int y) { System.out.println(\"Drawing Circle[ color: green, radius: \" + radius +\", x: \" +x+\", \"+ y +\"]\"); } } 步骤 3 使用 DrawAPI 接口创建抽象类 Shape。 public abstract class Shape { protected DrawAPI drawAPI; protected Shape(DrawAPI drawAPI){ this.drawAPI = drawAPI; } public abstract void draw(); } 步骤 4 创建实现了 Shape 抽象类的实体类。 public class Circle extends Shape { private int x, y, radius; public Circle(int x, int y, int radius, DrawAPI drawAPI) { super(drawAPI); this.x = x; this.y = y; this.radius = radius; } public void draw() { drawAPI.drawCircle(radius,x,y); } } 步骤 5 使用 Shape 和 DrawAPI 类画出不同颜色的圆。 public class BridgePatternDemo { public static void main(String[] args) { Shape redCircle = new Circle(100,100, 10, new RedCircle()); Shape greenCircle = new Circle(100,100, 10, new GreenCircle()); redCircle.draw(); greenCircle.draw(); } } 步骤 6 执行程序，输出结果： Drawing Circle[ color: red, radius: 10, x: 100, 100] Drawing Circle[ color: green, radius: 10, x: 100, 100] "},"学习资料/Java/设计模式/行为型模式/行为型模式.html":{"url":"学习资料/Java/设计模式/行为型模式/行为型模式.html","title":"行为型模式","keywords":"","body":"行为型模式 这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern） "},"学习资料/Java/设计模式/行为型模式/策略模式.html":{"url":"学习资料/Java/设计模式/行为型模式/策略模式.html","title":"策略模式","keywords":"","body":" 策略模式 一、介绍 二、实现 步骤 1 步骤 2 步骤 3 步骤 4 步骤 5 策略模式 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 一、介绍 意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。 何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。 如何解决：将这些算法封装成一个一个的类，任意地替换。 关键代码：实现同一个接口。 应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。 优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。 缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。 使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 二、实现 我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。 StrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。 步骤 1 创建一个接口。 public interface Strategy { public int doOperation(int num1, int num2); } 步骤 2 创建实现接口的实体类。 public class OperationAdd implements Strategy{ @Override public int doOperation(int num1, int num2) { return num1 + num2; } } public class OperationSubtract implements Strategy{ @Override public int doOperation(int num1, int num2) { return num1 - num2; } } public class OperationMultiply implements Strategy{ @Override public int doOperation(int num1, int num2) { return num1 * num2; } } 步骤 3 创建 Context 类。 public class Context { private Strategy strategy; public Context(Strategy strategy){ this.strategy = strategy; } public int executeStrategy(int num1, int num2){ return strategy.doOperation(num1, num2); } } 步骤 4 使用 Context 来查看当它改变策略 Strategy 时的行为变化。 public class StrategyPatternDemo { public static void main(String[] args) { Context context = new Context(new OperationAdd()); System.out.println(\"10 + 5 = \" + context.executeStrategy(10, 5)); context = new Context(new OperationSubtract()); System.out.println(\"10 - 5 = \" + context.executeStrategy(10, 5)); context = new Context(new OperationMultiply()); System.out.println(\"10 * 5 = \" + context.executeStrategy(10, 5)); } } 步骤 5 执行程序，输出结果： 10 + 5 = 15 10 - 5 = 5 10 * 5 = 50 "},"学习资料/Java/设计模式/行为型模式/中介者模式.html":{"url":"学习资料/Java/设计模式/行为型模式/中介者模式.html","title":"中介者模式","keywords":"","body":" 中介者模式 一、介绍 二、实现 步骤 1 步骤 2 步骤 3 步骤 4 三、观察者模式和责任链模式对比 中介者模式 中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。 一、介绍 意图： 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 主要解决： 对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。 何时使用： 多个类相互耦合，形成了网状结构。 如何解决： 将上述网状结构分离为星型结构。 关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。 应用实例： 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。 优点： 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。 缺点： 中介者会庞大，变得复杂难以维护。 使用场景： 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。 注意事项： 不应当在职责混乱的时候使用。 二、实现 我们通过聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 ChatRoom 和 User。User 对象使用 ChatRoom 方法来分享他们的消息。 MediatorPatternDemo，我们的演示类使用 User 对象来显示他们之间的通信。 步骤 1 创建中介类。 import java.util.Date; public class ChatRoom { public static void showMessage(User user, String message){ System.out.println(new Date().toString() + \" [\" + user.getName() +\"] : \" + message); } } 步骤 2 创建 user 类。 public class User { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public User(String name){ this.name = name; } public void sendMessage(String message){ ChatRoom.showMessage(this,message); } } 步骤 3 使用 User 对象来显示他们之间的通信。 public class MediatorPatternDemo { public static void main(String[] args) { User robert = new User(\"Robert\"); User john = new User(\"John\"); robert.sendMessage(\"Hi! John!\"); john.sendMessage(\"Hello! Robert!\"); } } 步骤 4 执行程序，输出结果： Thu Jan 31 16:05:46 IST 2013 [Robert] : Hi! John! Thu Jan 31 16:05:46 IST 2013 [John] : Hello! Robert! 三、观察者模式和责任链模式对比 待完善。。 "},"学习资料/Java/设计模式/行为型模式/责任链模式.html":{"url":"学习资料/Java/设计模式/行为型模式/责任链模式.html","title":"责任链模式","keywords":"","body":" 责任链模式 一、介绍 二、实现 步骤 1 步骤 2 步骤 3 步骤 4 责任链模式 顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。 在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 一、介绍 意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。 何时使用：在处理消息的时候以过滤很多道。 如何解决：拦截的类都实现统一接口。 关键代码：Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。 应用实例： 1、红楼梦中的\"击鼓传花\"。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。 优点： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。 缺点： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。 使用场景： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。 注意事项：在 JAVA WEB 中遇到很多应用。 二、实现 我们创建抽象类 AbstractLogger，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 AbstractLogger。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。 步骤 1 创建抽象的记录器类 public abstract class AbstractLogger { public static int INFO = 1; public static int DEBUG = 2; public static int ERROR = 3; protected int level; //责任链中的下一个元素 protected AbstractLogger nextLogger; public void setNextLogger(AbstractLogger nextLogger){ this.nextLogger = nextLogger; } public void logMessage(int level, String message){ if(this.level 步骤 2 创建扩展了该记录器类的实体类。 public class ConsoleLogger extends AbstractLogger { public ConsoleLogger(int level){ this.level = level; } @Override protected void write(String message) { System.out.println(\"Standard Console::Logger: \" + message); } } public class ErrorLogger extends AbstractLogger { public ErrorLogger(int level){ this.level = level; } @Override protected void write(String message) { System.out.println(\"Error Console::Logger: \" + message); } } public class FileLogger extends AbstractLogger { public FileLogger(int level){ this.level = level; } @Override protected void write(String message) { System.out.println(\"File::Logger: \" + message); } } 步骤 3 创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分。 public class ChainPatternDemo { private static AbstractLogger getChainOfLoggers(){ AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR); AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG); AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO); errorLogger.setNextLogger(fileLogger); fileLogger.setNextLogger(consoleLogger); return errorLogger; } public static void main(String[] args) { AbstractLogger loggerChain = getChainOfLoggers(); loggerChain.logMessage(AbstractLogger.INFO, \"This is an information.\"); loggerChain.logMessage(AbstractLogger.DEBUG, \"This is a debug level information.\"); loggerChain.logMessage(AbstractLogger.ERROR, \"This is an error information.\"); } } 步骤 4 执行程序，输出结果： Standard Console::Logger: This is an information. File::Logger: This is a debug level information. Standard Console::Logger: This is a debug level information. Error Console::Logger: This is an error information. File::Logger: This is an error information. Standard Console::Logger: This is an error information. "},"学习资料/Java/设计模式/行为型模式/观察者模式.html":{"url":"学习资料/Java/设计模式/行为型模式/观察者模式.html","title":"观察者模式","keywords":"","body":" 观察者模式 一、介绍 二、实现 步骤 1 步骤 2 步骤 3 步骤 4 步骤 5 三、观察者模式与责任链模式对比 观察者模式 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。 一、介绍 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 如何解决：使用面向对象技术，可以将这种依赖关系弱化。 关键代码：在抽象类里有一个 ArrayList 存放观察者们。 应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。 优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。 缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 使用场景： 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。 注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。 二、实现 观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。 ObserverPatternDemo，我们的演示类使用 Subject 和实体类对象来演示观察者模式。 步骤 1 创建 Subject 类。 import java.util.ArrayList; import java.util.List; public class Subject { private List observers = new ArrayList(); private int state; public int getState() { return state; } public void setState(int state) { this.state = state; notifyAllObservers(); } public void attach(Observer observer){ observers.add(observer); } public void notifyAllObservers(){ for (Observer observer : observers) { observer.update(); } } } 步骤 2 创建 Observer 类。 public abstract class Observer { protected Subject subject; public abstract void update(); } 步骤 3 创建实体观察者类。 public class BinaryObserver extends Observer{ public BinaryObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \"Binary String: \" + Integer.toBinaryString( subject.getState() ) ); } } public class OctalObserver extends Observer{ public OctalObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \"Octal String: \" + Integer.toOctalString( subject.getState() ) ); } } public class HexaObserver extends Observer{ public HexaObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \"Hex String: \" + Integer.toHexString( subject.getState() ).toUpperCase() ); } } 步骤 4 使用 Subject 和实体观察者对象。 public class ObserverPatternDemo { public static void main(String[] args) { Subject subject = new Subject(); new HexaObserver(subject); new OctalObserver(subject); new BinaryObserver(subject); System.out.println(\"First state change: 15\"); subject.setState(15); System.out.println(\"Second state change: 10\"); subject.setState(10); } } 步骤 5 执行程序，输出结果： First state change: 15 Hex String: F Octal String: 17 Binary String: 1111 Second state change: 10 Hex String: A Octal String: 12 Binary String: 1010 三、观察者模式与责任链模式对比 待完善... "},"学习资料/Java/设计模式/行为型模式/迭代器模式.html":{"url":"学习资料/Java/设计模式/行为型模式/迭代器模式.html","title":"迭代器模式","keywords":"","body":" 迭代器模式 一、介绍 二、实现 步骤 1 步骤 2 步骤 3 步骤 4 迭代器模式 迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。 迭代器模式属于行为型模式。 一、介绍 意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。 主要解决：不同的方式来遍历整个整合对象。 何时使用：遍历一个聚合对象。 如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。 关键代码：定义接口：hasNext, next。 应用实例：JAVA 中的 iterator。 优点： 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。 缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。 使用场景： 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。 注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。 二、实现 我们将创建一个叙述导航方法的 Iterator 接口和一个返回迭代器的 Container 接口。实现了 Container 接口的实体类将负责实现 Iterator 接口。 IteratorPatternDemo，我们的演示类使用实体类 NamesRepository 来打印 NamesRepository 中存储为集合的 Names。 步骤 1 创建接口: public interface Iterator { public boolean hasNext(); public Object next(); } public interface Container { public Iterator getIterator(); } 步骤 2 创建实现了 Container 接口的实体类。该类有实现了 Iterator 接口的内部类 NameIterator。 public class NameRepository implements Container { public String[] names = {\"Robert\" , \"John\" ,\"Julie\" , \"Lora\"}; @Override public Iterator getIterator() { return new NameIterator(); } private class NameIterator implements Iterator { int index; @Override public boolean hasNext() { if(index 步骤 3 使用 NameRepository 来获取迭代器，并打印名字。 public class IteratorPatternDemo { public static void main(String[] args) { NameRepository namesRepository = new NameRepository(); for(Iterator iter = namesRepository.getIterator(); iter.hasNext();){ String name = (String)iter.next(); System.out.println(\"Name : \" + name); } } } 步骤 4 执行程序，输出结果： Name : Robert Name : John Name : Julie Name : Lora "},"学习资料/Java/设计模式/行为型模式/访问者模式.html":{"url":"学习资料/Java/设计模式/行为型模式/访问者模式.html","title":"访问者模式","keywords":"","body":" 访问者模式 介绍 实现 步骤 1 步骤 2 步骤 3 步骤 4 步骤 5 步骤 6 访问者模式 在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。 介绍 意图：主要将数据结构与数据操作分离。 主要解决：稳定的数据结构和易变的操作耦合问题。 何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，使用访问者模式将这些封装到类中。 如何解决：在被访问的类里面加一个对外提供接待访问者的接口。 关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。 应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。 优点： 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。 缺点： 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。 使用场景： 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，也不希望在增加新操作时修改这些类。 注意事项：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。 实现 我们将创建一个定义接受操作的 ComputerPart 接口。Keyboard、Mouse、Monitor 和 Computer 是实现了 ComputerPart 接口的实体类。我们将定义另一个接口 ComputerPartVisitor，它定义了访问者类的操作。Computer 使用实体访问者来执行相应的动作。 VisitorPatternDemo，我们的演示类使用 Computer、ComputerPartVisitor 类来演示访问者模式的用法。 步骤 1 定义一个表示元素的接口。 public interface ComputerPart { public void accept(ComputerPartVisitor computerPartVisitor); } 步骤 2 创建扩展了上述类的实体类。 public class Keyboard implements ComputerPart { @Override public void accept(ComputerPartVisitor computerPartVisitor) { computerPartVisitor.visit(this); } } public class Monitor implements ComputerPart { @Override public void accept(ComputerPartVisitor computerPartVisitor) { computerPartVisitor.visit(this); } } public class Mouse implements ComputerPart { @Override public void accept(ComputerPartVisitor computerPartVisitor) { computerPartVisitor.visit(this); } } public class Computer implements ComputerPart { ComputerPart[] parts; public Computer(){ parts = new ComputerPart[] {new Mouse(), new Keyboard(), new Monitor()}; } @Override public void accept(ComputerPartVisitor computerPartVisitor) { for (int i = 0; i 步骤 3 定义一个表示访问者的接口。 public interface ComputerPartVisitor { public void visit(Computer computer); public void visit(Mouse mouse); public void visit(Keyboard keyboard); public void visit(Monitor monitor); } 步骤 4 创建实现了上述类的实体访问者。 public class ComputerPartDisplayVisitor implements ComputerPartVisitor { @Override public void visit(Computer computer) { System.out.println(\"Displaying Computer.\"); } @Override public void visit(Mouse mouse) { System.out.println(\"Displaying Mouse.\"); } @Override public void visit(Keyboard keyboard) { System.out.println(\"Displaying Keyboard.\"); } @Override public void visit(Monitor monitor) { System.out.println(\"Displaying Monitor.\"); } } 步骤 5 使用 ComputerPartDisplayVisitor 来显示 Computer 的组成部分。 public class VisitorPatternDemo { public static void main(String[] args) { ComputerPart computer = new Computer(); computer.accept(new ComputerPartDisplayVisitor()); } } 步骤 6 执行程序，输出结果： Displaying Mouse. Displaying Keyboard. Displaying Monitor. Displaying Computer. "},"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇.html":{"url":"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇.html","title":"JVM上篇：内存与垃圾回收篇","keywords":"","body":"笔记来源：尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机） "},"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/JVM与Java体系结构.html":{"url":"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/JVM与Java体系结构.html","title":"1.JVM与Java体系结构","keywords":"","body":" 1.JVM与Java体系结构 1.1. 前言 1.2. 面向人群及参考书目 1.3. Java及JVM简介 1.4. Java发展的重大事件 1.5. 虚拟机与Java虚拟机 1.6. JVM的整体结构 1.7. Java代码执行流程 1.8. JVM的架构模型 1.9. JVM的生命周期 1.JVM与Java体系结构 1.1. 前言 作为Java工程师的你曾被伤害过吗？你是否也遇到过这些问题？ 运行着的线上系统突然卡死，系统无法访问，甚至直接OOM 想解决线上JVM GC问题，但却无从下手 新项目上线，对各种JVM参数设置一脸茫然，直接默认吧然后就JJ了 每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼 大部分Java开发人员，除会在项目中使用到与Java平台相关的各种高精尖技术，对于Java技术的核心Java虚拟机了解甚少。 开发人员如何看待上层框架 一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。 如果我们把核心类库的API比做数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。 计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言 我们为什么要学习JVM？ 面试的需要（BATJ、TMD，PKQ等面试都爱问） 中高级程序员必备技能 项目管理、调优的需求 追求极客的精神 比如：垃圾回收算法、JIT、底层原理 Java vs C++ 垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。 1.2. 面向人群及参考书目 1.3. Java及JVM简介 TIOBE语言热度排行榜：index | TIOBE - The Software Quality Company Programming Language 2021 2016 2011 2006 2001 1996 1991 1986 C 1 2 2 2 1 1 1 1 Java 2 1 1 1 3 26 - - Python 3 5 6 8 27 19 - - C++ 4 3 3 3 2 2 2 8 C# 5 4 5 7 13 - - - Visual Basic 6 13 - - - - - - JavaScript 7 8 10 9 10 32 - - PHP 8 6 4 4 11 - - - SQL 9 - - - - - - - R 10 17 31 - - - - - Lisp 34 27 13 14 17 7 4 2 Ada 36 28 17 16 20 8 5 3 (Visual) Basic - - 7 6 4 3 3 5 世界上没有最好的编程语言，只有最适用于具体应用场景的编程语言 JVM：跨语言的平台 Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。 作为一个平台，Java虚拟机扮演着举足轻重的作用 Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分 作为灯种文化，Java几乎成为了“开源”的代名词。 第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。 就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。 作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。 每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过Java虚拟机进行运行和处理 随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。 Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。 字节码 我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。 不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。 Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式—Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。 多语言混合编程 Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。 试想一下，在一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。 对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如Da Vinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。 如何真正搞懂JVM？ Java虚拟机非常复杂，要想真正理解它的工作原理，最好的方式就是自己动手编写一个！ 自己动手写一个Java虚拟机，难吗？ 天下事有难易乎？ 为之，则难者亦易矣；不为，则易者亦难矣 1.4. Java发展的重大事件 1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出的新的程序语言，命名为oak，后期命名为Java 1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相。 1996年1月23日，Sun Microsystems发布了JDK 1.0。 1998年，JDK1.2版本发布。同时，sun发布了JSP/Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。 2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。 2002年，JDK1.4发布，古老的Classic虚拟机退出历史舞台。 2003年年底，Java平台的Scala正式发布，同年Groovy也加入了Java阵营。 2004年，JDK1.5发布。同时JDK1.5改名为JavaSE5.0。 2006年，JDK6发布。同年，Java开源并建立了OpenJDK。顺理成章，Hotspot虚拟机也成为了openJDK中的默认虚拟机。 2007年，Java平台迎来了新伙伴Clojure。 2008年，Oracle收购了BEA，得到了JRockit虚拟机。 2009年，Twitter宣布把后台大部分程序从Ruby迁移到Scala，这是Java平台的又一次大规模应用。 2010年，Oracle收购了Sun，获得Java商标和最真价值的HotSpot虚拟机。此时，Oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit 2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。 2017年，JDK9发布。将G1设置为默认Gc，替代CMS 同年，IBM的J9开源，形成了现在的Open J9社区 2018年，Android的Java侵权案判决，Google赔偿Oracle计88亿美元 同年，Oracle宣告JavaEE成为历史名词JDBC、JMS、Servlet赠予Eclipse基金会 同年，JDK11发布，LTS版本的JDK，发布革命性的ZGC，调整JDK授权许可 2019年，JDK12发布，加入RedHat领导开发的shenandoah GC 在JDK11之前，OracleJDK中还会存在一些OpenJDK中没有的、闭源的功能。但在JDK11中，我们可以认为OpenJDK和OracleJDK代码实质上已经完全一致的程度。 不过，主流的 JDK 8 在2019年01月之后就被宣布停止更新了。另外， JDK 11 及以后的版本也不再提供免费的长期支持（LTS），而且 JDK 15 和 JDK 16 也不是一个长期支持的版本，最新的 JDK 15 只支持 6 个月时间，到 2021 年 3 月，所以千万不要把 JDK 15 等非长期支持版本用在生产。 1.5. 虚拟机与Java虚拟机 虚拟机 所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。 大名鼎鼎的Visual Box，Mware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。 程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。 无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。 Java虚拟机 Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。 JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。 Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。 作用 Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。 特点 一次编译，到处运行 自动内存管理 自动垃圾回收功能 JVM的位置 JVM是运行在操作系统之上的，它与硬件没有直接的交互 1.6. JVM的整体结构 HotSpot VM是目前市面上高性能虚拟机的代表作之一。 它采用解释器与即时编译器并存的架构。 在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。 1.7. Java代码执行流程 1.8. JVM的架构模型 Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。 具体来说：这两种架构之间的区别： 基于栈式架构的特点 设计和实现更简单，适用于资源受限的系统 避开了寄存器的分配难题：使用零地址指令方式分配 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现 不需要硬件支持，可移植性更好，更好实现跨平台 基于寄存器架构的特点 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机 指令集架构则完全依赖硬件，可移植性差 性能优秀和执行更高效 花费更少的指令去完成一项操作 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主 举例1 同样执行2+3这种逻辑操作，其指令分别如下： 基于栈的计算流程（以Java虚拟机为例）： iconst_2 //常量2入栈 istore_1 iconst_3 // 常量3入栈 istore_2 iload_1 iload_2 iadd //常量2/3出栈，执行相加 istore_0 // 结果5入栈 而基于寄存器的计算流程 mov eax,2 //将eax寄存器的值设为1 add eax,3 //使eax寄存器的值加3 举例2 public int calc(){ int a=100; int b=200; int c=300; return (a + b) * c; } > javap -c Test.class ... public int calc(); Code: Stack=2,Locals=4,Args_size=1 0: bipush 100 2: istore_1 3: sipush 200 6: istore_2 7: sipush 300 10: istore_3 11: iload_1 12: iload_2 13: iadd 14: iload_3 15: imul 16: ireturn } 总结 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。 时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？ 1.9. JVM的生命周期 虚拟机的启动 Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。 虚拟机的执行 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。 程序开始执行时他才运行，程序结束时他就停止。 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。 虚拟机的退出 有如下的几种情况： 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统用现错误而导致Java虚拟机进程终止 某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。 除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。 "},"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/类加载子系统.html":{"url":"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/类加载子系统.html","title":"2.类加载子系统","keywords":"","body":" 2. 类加载子系统 2.1. 内存结构概述 2.2. 类加载器与类的加载过程 加载阶段 链接阶段 初始化阶段 2.3. 类加载器分类 2.3.1. 虚拟机自带的加载器 2.3.2. 用户自定义类加载器 2.4. ClassLoader的使用说明 2.5. 双亲委派机制 2.6. 其他 2. 类加载子系统 2.1. 内存结构概述 Class文件 类加载子系统 运行时数据区 方法区 堆 程序计数器 虚拟机栈 本地方法栈 执行引擎 本地方法接口 本地方法库 如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？ 类加载器 执行引擎 2.2. 类加载器与类的加载过程 类加载器子系统作用 类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。 ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。 加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射） 类加载器ClasLoader角色 class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。 class file加载到JVM中，被称为DNA元数据模板，放在方法区。 在.class文件->JVM->最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。 类的加载过程 /** *示例代码 */ public class HelloLoader { public static void main(String[] args) { System.out.println(\"Hello World!\"); } } 用流程图表示上述示例代码： 加载阶段 通过一个类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 补充：加载class文件的方式 从本地系统中直接加载 通过网络获取，典型场景：Web Applet 从zip压缩包中读取，成为日后jar、war格式的基础 运行时计算生成，使用最多的是：动态代理技术 由其他文件生成，典型场景：JSP应用 从专有数据库中提取.class文件，比较少见 从加密文件中获取，典型的防Class文件被反编译的保护措施 链接阶段 验证（Verify）： 目的在子确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。 准备（Prepare）： 为类变量分配内存并且设置该类变量的默认初始值，即零值。 这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化； 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。 解析（Resolve）： 将常量池内的符号引用转换为直接引用的过程。 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。 初始化阶段 初始化阶段就是执行类构造器方法()的过程。 此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。 构造器方法中指令按语句在源文件中出现的顺序执行。 ()不同于类的构造器。（关联：构造器是虚拟机视角下的() 若该类具有父类，JVM会保证子类的()执行前，父类的()已经执行完毕。 虚拟机必须保证一个类的()方法在多线程下被同步加锁。 2.3. 类加载器分类 JVM支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。 无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示： 这里的四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。 2.3.1. 虚拟机自带的加载器 启动类加载器（引导类加载器，Bootstrap ClassLoader） 这个类加载使用C/C++语言实现的，嵌套在JVM内部。 它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类 并不继承自ava.lang.ClassLoader，没有父加载器。 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 扩展类加载器（Extension ClassLoader） Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。 派生于ClassLoader类 父类加载器为启动类加载器 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。 应用程序类加载器（系统类加载器，AppClassLoader） java语言编写，由sun.misc.LaunchersAppClassLoader实现 派生于ClassLoader类 父类加载器为扩展类加载器 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载 通过ClassLoader#getSystemclassLoader() 方法可以获取到该类加载器 2.3.2. 用户自定义类加载器 在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？ 隔离加载类 修改类加载的方式 扩展加载源 防止源码泄漏 用户自定义类加载器实现步骤： 开发人员可以通过继承抽象类ava.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求 在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass() 方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadclass() 方法，而是建议把自定义的类加载逻辑写在findClass()方法中 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。 2.4. ClassLoader的使用说明 ClassLoader类是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器） sun.misc.Launcher 它是一个java虚拟机的入口应用 获取ClassLoader的途径 方式一：获取当前ClassLoader clazz.getClassLoader() 方式二：获取当前线程上下文的ClassLoader Thread.currentThread().getContextClassLoader() 方式三：获取系统的ClassLoader ClassLoader.getSystemClassLoader() 方式四：获取调用者的ClassLoader DriverManager.getCallerClassLoader() 2.5. 双亲委派机制 Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。 工作原理 1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行； 2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器； 3）如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。 举例 当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类jdbc.jar的加载。 优势 避免类的重复加载 保护程序安全，防止核心API被随意篡改 自定义类：java.lang.String 自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类） 沙箱安全机制 自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\\lang\\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。 2.6. 其他 如何判断两个class对象是否相同 在JVM中表示两个class对象是否为同一个类存在两个必要条件： 类的完整类名必须一致，包括包名。 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。 换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。 对类加载器的引用 JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。 类的主动使用和被动使用 Java程序对类的使用方式分为：主动使用和被动使用。 主动使用，又分为七种情况： 创建类的实例 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（比如：Class.forName（\"com.atguigu.Test\"）） 初始化一个类的子类 Java虚拟机启动时被标明为启动类的类 JDK 7 开始提供的动态语言支持： java.lang.invoke.MethodHandle实例的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化 除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。 "},"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/运行时数据区及程序计数器.html":{"url":"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/运行时数据区及程序计数器.html","title":"3.运行时数据区及程序计数器","keywords":"","body":" 3. 运行时数据区及程序计数器 3.1. 运行时数据区 3.1.1. 概述 3.1.2. 线程 3.1.3. JVM系统线程 3.2. 程序计数器(PC寄存器) 3. 运行时数据区及程序计数器 3.1. 运行时数据区 3.1.1. 概述 本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段 当我们通过前面的：类的加载-> 验证 -> 准备 -> 解析 -> 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区 内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。 我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品 我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁 Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。 灰色的为单独线程私有的，红色的为多个线程共享的。即： 每个线程：独立包括程序计数器、栈、本地栈。 线程间共享：堆、堆外内存（永久代或元空间、代码缓存） 每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。 3.1.2. 线程 线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。 操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。 3.1.3. JVM系统线程 如果你使用console或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main(String[] args)的main线程以及所有这个main线程自己创建的线程。 这些主要的后台系统线程在Hotspot JVM里主要是以下几个： 虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括\"stop-the-world\"的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。 GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。 编译线程：这种线程在运行时会将字节码编译成到本地代码。 信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。 3.2. 程序计数器(PC寄存器) JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。 作用 PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefined）。 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 它是唯一一个在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。 举例说明 public int minus(){ intc = 3; intd = 4; return c - d; } 字节码文件： 0: iconst_3 1: istore_1 2: iconst_4 3: istore_2 4: iload_1 5: iload_2 6: isub 7: ireturn 使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？ 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。 JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。 由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。 这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。 CPU时间片 CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。 在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。 但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。 "},"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/虚拟机栈.html":{"url":"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/虚拟机栈.html","title":"4.虚拟机栈","keywords":"","body":" 4. 虚拟机栈 4.1. 虚拟机栈概述 4.1.1. 虚拟机栈出现的背景 4.1.2. 初步印象 4.1.3. 内存中的栈与堆 4.1.4. 虚拟机栈基本内容 Java虚拟机栈是什么？ 生命周期 作用 栈的特点 面试题：开发中遇到哪些异常？ 4.2. 栈的存储单位 4.2.1. 栈中存储什么？ 4.2.2. 栈运行原理 4.2.3. 栈帧的内部结构 4.3. 局部变量表(Local Variables) 4.3.1. 关于Slot的理解 4.3.2. Slot的重复利用 4.3.3. 静态变量与局部变量的对比 4.3.4. 补充说明 4.4. 操作数栈（Operand Stack） 4.5. 代码追踪 4.6. 栈顶缓存技术（Top Of Stack Cashing）技术 4.7. 动态链接（Dynamic Linking） 4.8. 方法的调用：解析与分配 4.8.1. 静态链接 4.8.3. 早期绑定 4.8.4. 晚期绑定 4.8.5. 虚方法和非虚方法 普通调用指令： 动态调用指令： 动态类型语言和静态类型语言 4.8.6. 方法重写的本质 4.8.7. 方法的调用：虚方法表 4.9. 方法返回地址（return address） 4.10. 一些附加信息 4.11. 栈的相关面试题 4. 虚拟机栈 4.1. 虚拟机栈概述 4.1.1. 虚拟机栈出现的背景 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。 4.1.2. 初步印象 有不少Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有Java堆（heap）和Java栈（stack）？为什么？ 4.1.3. 内存中的栈与堆 栈是运行时的单位，而堆是存储的单位 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。 堆解决的是数据存储的问题，即数据怎么放，放哪里 4.1.4. 虚拟机栈基本内容 Java虚拟机栈是什么？ Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用，是线程私有的。 生命周期 生命周期和线程一致 作用 主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。 栈的特点 栈是一种快速有效的分配存储方式，访问速度仅次于罹序计数器。 JVM直接对Java栈的操作只有两个： 每个方法执行，伴随着进栈（入栈、压栈） 执行结束后的出栈工作 对于栈来说不存在垃圾回收问题（栈存在溢出的情况） 面试题：开发中遇到哪些异常？ 栈中可能出现的异常 Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。 ● 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError 异常。 ● 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 OutOfMemoryError 异常。 public static void main(String[] args) { test(); } public static void test() { test(); } //抛出异常：Exception in thread\"main\"java.lang.StackoverflowError //程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。 设置栈内存大小 我们可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度 public class StackDeepTest{ private static int count=0; public static void recursion(){ count++; recursion(); } public static void main(String args[]){ try{ recursion(); } catch (Throwable e){ System.out.println(\"deep of calling=\"+count); e.printstackTrace(); } } } 4.2. 栈的存储单位 4.2.1. 栈中存储什么？ 每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。 在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。 4.2.2. 栈运行原理 JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。 Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。 public class CurrentFrameTest{ public void methodA(){ system.out.println（\"当前栈帧对应的方法->methodA\"); methodB(); system.out.println（\"当前栈帧对应的方法->methodA\"); } public void methodB(){ System.out.println（\"当前栈帧对应的方法->methodB\"); } 4.2.3. 栈帧的内部结构 每个栈帧中存储着： 局部变量表（Local Variables） 操作数栈（operand Stack）（或表达式栈） 动态链接（DynamicLinking）（或指向运行时常量池的方法引用） 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义） 一些附加信息 并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的 4.3. 局部变量表(Local Variables) 局部变量表也被称之为局部变量数组或本地变量表 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题 局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。 局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 4.3.1. 关于Slot的理解 局部变量表，最基本的存储单元是Slot（变量槽） 参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。 局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。 在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。 byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。 JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量） 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。 4.3.2. Slot的重复利用 栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。 public class SlotTest { public void localVarl() { int a = 0; System.out.println(a); int b = 0; } public void localVar2() { { int a = 0; System.out.println(a); } //此时的就会复用a的槽位 int b = 0; } } 4.3.3. 静态变量与局部变量的对比 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。 我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。 和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。 public void test(){ int i; System. out. println(i);//这样的代码是错误的，没有赋值不能够使用。 } 这样的代码是错误的，没有赋值不能够使用。 4.3.4. 补充说明 在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。 4.4. 操作数栈（Operand Stack） 每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的 操作数栈，也可以称之为表达式栈（Expression Stack） 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop） 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈 比如：执行复制、交换、求和等操作 代码举例 public void testAddOperation(){ byte i = 15; int j = 8; int k = i + j; } 字节码指令信息 public void testAddOperation(); Code: 0: bipush 15 2: istore_1 3: bipush 8 5: istore_2 6:iload_1 7:iload_2 8:iadd 9:istore_3 10:return 操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。 栈中的任何一个元素都是可以任意的Java数据类型 32bit的类型占用一个栈单位深度 64bit的类型占用两个栈单位深度 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。 另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。 4.5. 代码追踪 public void testAddOperation() { byte i = 15; int j = 8; int k = i + j; } 使用javap 命令反编译class文件：javap -v 类名.class public void testAddoperation(); Code: 0: bipush 15 2: istore_1 3: bipush 8 5: istore_2 6: iload_1 7: iload_2 8: iadd 9: istore_3 10: return 程序员面试过程中，常见的i++和++i的区别，放到字节码篇章时再介绍。 4.6. 栈顶缓存技术（Top Of Stack Cashing）技术 前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。 4.7. 动态链接（Dynamic Linking） 动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。 为什么需要运行时常量池呢？ 常量池的作用：就是为了提供一些符号和常量，便于指令的识别 4.8. 方法的调用：解析与分配 在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关 4.8.1. 静态链接 当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时，这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接 4.8.2. 动态链接 如果被调用的方法在编译期无法被确定下来，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。 静态链接和动态链接不是名词，而是动词，这是理解的关键。 对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。 4.8.3. 早期绑定 早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。 4.8.4. 晚期绑定 如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。 随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特悄，那么自然也就具备早期绑定和晚期绑定两种绑定方式。 Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C语言中的虚函数（C中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。 4.8.5. 虚方法和非虚方法 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。其他方法称为虚方法。 在类加载的解析阶段就可以进行解析，如下是非虚方法举例： class Father{ public static void print(String str){ System. out. println(\"father \"+str); } private void show(String str){ System. out. println(\"father\"+str); } } class Son extends Father{ public class VirtualMethodTest{ public static void main(String[] args){ Son.print(\"coder\"); //Father fa=new Father(); //fa.show(\"atguigu.com\"); } } 虚拟机中提供了以下几条方法调用指令： 普通调用指令： invokestatic：调用静态方法，解析阶段确定唯一方法版本 invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本 invokevirtual：调用所有虚方法 invokeinterface：调用接口方法 动态调用指令： invokedynamic：动态解析出需要调用的方法，然后执行 前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（fina1修饰的除外）称为虚方法。 关于invokednamic指令 JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现「动态类型语言」支持而做的一种改进。 但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。 Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。 动态类型语言和静态类型语言 动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。 说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。 4.8.6. 方法重写的本质 Java 语言中方法重写的本质： 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。 如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError 异常。 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。 如果始终没有找到合适的方法，则抛出java.1ang.AbstractMethodsrror异常。 IllegalAccessError介绍 程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。 4.8.7. 方法的调用：虚方法表 在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表 （virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。 虚方法表是什么时候被创建的呢？ 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。 举例2： interface Friendly{ void sayHello(); void sayGoodbye(); } class Dog{ public void sayHello(){ } public String tostring(){ return \"Dog\"; } } class Cat implements Friendly { public void eat() { } public void sayHello() { } public void sayGoodbye() { } protected void finalize() { } } class CockerSpaniel extends Dog implements Friendly{ public void sayHello() { super.sayHello(); } public void sayGoodbye() { } } 4.9. 方法返回地址（return address） 存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式： 正常执行完成 出现未处理的异常，非正常退出 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。 当一个方法开始执行后，只有两种方式可以退出这个方法： 执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口； 在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。 Exception table: from to target type 4 16 19 any 19 21 19 any 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。 正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。 4.10. 一些附加信息 栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息 4.11. 栈的相关面试题 举例栈溢出的情况？（StackOverflowError） 通过 -Xss设置栈的大小 调整栈大小，就能保证不出现溢出么？ 不能保证不溢出 分配的栈内存越大越好么？ 不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。 垃圾回收是否涉及到虚拟机栈？ 不会 方法中定义的局部变量是否线程安全？ 具体问题具体分析。如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。 运行时数据区 是否存在Error 是否存在GC 程序计数器 否 否 虚拟机栈 是（SOE） 否 本地方法栈 是 否 方法区 是（OOM） 是 堆 是 是 "},"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/本地方法接口和本地方法栈.html":{"url":"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/本地方法接口和本地方法栈.html","title":"5.本地方法接口和本地方法栈","keywords":"","body":" 5. 本地方法接口和本地方法栈 5.1. 什么是本地方法？ 5.2. 为什么使用Native Method？ 5.3. 本地方法栈 5. 本地方法接口和本地方法栈 5.1. 什么是本地方法？ 简单地讲，一个Native Method是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C中，你可以用extern \"c\" 告知c编译器去调用一个c的函数。 A native method is a Java method whose implementation is provided by non-java code. 在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。 本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。 举例 public class IHaveNatives{ public native void methodNative1(int x); public native static long methodNative2(); private native synchronized float methodNative3(Object o); native void methodNative4(int[] ary) throws Exception; } 标识符native可以与其它java标识符连用，但是abstract除外 5.2. 为什么使用Native Method？ Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。 与Java环境的交互 有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。 与操作系统的交互 JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。 Sun's Java 由于Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setPriority() ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。 现状 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。 5.3. 本地方法栈 Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。 本地方法栈，也是线程私有的。 允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的） 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError 异常。 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。 本地方法是使用C语言实现的。 它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。 当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。 它甚至可以直接使用本地处理器中的寄存器 直接从本地内存的堆中分配任意数量的内存。 并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。 在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。 "},"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/堆.html":{"url":"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/堆.html","title":"6.堆","keywords":"","body":" 6. 堆 6.1. 堆（Heap）的核心概述 6.1.1. 堆内存细分 6.1.2. 堆空间内部结构（JDK7） 6.1.3. 堆空间内部结构（JDK8） 6.2. 设置堆内存大小与OOM 6.2.1. 堆空间大小的设置 6.2.2. OutOfMemory举例 6.3. 年轻代与老年代 6.4. 图解对象分配过程 6.5. Minor GC，MajorGC、Full GC 6.5.1. 最简单的分代式GC策略的触发条件 年轻代GC（Minor GC）触发机制 老年代GC（Major GC / Full GC）触发机制 Full GC触发机制（后面细讲）： 6.6. 堆空间分代思想 6.7. 内存分配策略 6.8. 为对象分配内存：TLAB 6.8.1. 为什么有TLAB（Thread Local Allocation Buffer）？ 6.8.2. 什么是TLAB？ 6.8.3. TLAB的再说明 6.9. 小结：堆空间的参数设置 6.X. 堆是分配对象的唯一选择么？ 6.X.1. 逃逸分析概述 6.X.2. 逃逸分析：代码优化 栈上分配 同步省略 标量替换 6.X.3. 逃逸分析小结：逃逸分析并不成熟 本章小结 6. 堆 6.1. 堆（Heap）的核心概述 堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。 Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。 堆内存的大小是可以调节的。 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。 《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated） 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。 堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。 6.1.1. 堆内存细分 Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区 Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区 Tenure generation space 养老区 Old/Tenure Permanent Space 永久区 Perm Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间 Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区 Tenure generation space 养老区 Old/Tenure Meta Space 元空间 Meta 约定：新生区（代）年轻代 、 养老区老年区（代）、 永久区永久代 6.1.2. 堆空间内部结构（JDK7） 6.1.3. 堆空间内部结构（JDK8） 6.2. 设置堆内存大小与OOM 6.2.1. 堆空间大小的设置 Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项\"-Xmx\"和\"-Xms\"来进行设置。 \"-Xms\"用于表示堆区的起始内存，等价于-XX:InitialHeapSize \"-Xmx\"则用于表示堆区的最大内存，等价于-XX:MaxHeapSize 一旦堆区中的内存大小超过“-Xmx\"所指定的最大内存时，将会抛出OutOfMemoryError异常。 开发通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。 默认情况下 初始内存大小：物理电脑内存大小 / 64 最大内存大小：物理电脑内存大小 / 4 6.2.2. OutOfMemory举例 public class OOMTest { public static void main(String[]args){ ArrayList list = new ArrayList<>(); while(true){ try { Thread.sleep(20); } catch (InterruptedException e){ e.printStackTrace(); } list.add(new Picture(new Random().nextInt(1024*1024))); } } } Exception in thread \"main\" java.lang.OutofMemoryError: Java heap space at com.atguigu. java.Picture.(OOMTest. java:25) at com.atguigu.java.O0MTest.main(OOMTest.java:16) 6.3. 年轻代与老年代 存储在JVM中的Java对象可以被划分为两类： 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致 Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen） 其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区） 下面这参数开发中一般不会调： 配置新生代与老年代在堆结构的占比。 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5 在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1 当然开发人员可以通过选项-xx:SurvivorRatio调整这个空间比例。比如-xx:SurvivorRatio=8 几乎所有的Java对象都是在Eden区被new出来的。 绝大部分的Java对象的销毁都在新生代进行了。可以使用选项-Xmn设置新生代最大内存大小，这个参数一般使用默认值就可以了。 6.4. 图解对象分配过程 为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。 new的对象先放伊甸园区。此区有大小限制。 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。 然后将伊甸园中的剩余对象移动到幸存者0区。 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。 啥时候能去养老区呢？可以设置次数。默认是15次。 可以设置参数：进行设置-Xx:MaxTenuringThreshold= N 在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。 若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。 java.lang.OutofMemoryError: Java heap space 流程图 总结 针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to 关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不在永久代和元空间进行收集 常用调优工具（在JVM下篇：性能监控与调优篇会详细介绍） JDK命令行 Eclipse:Memory Analyzer Tool Jconsole VisualVM Jprofiler Java Flight Recorder GCViewer GC Easy 6.5. Minor GC，MajorGC、Full GC JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。 针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC） 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为： 新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集 老年代收集（Major GC / Old GC）：只是老年代的圾收集。 目前，只有CMS GC会有单独收集老年代的行为。 注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。 混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。 目前，只有G1 GC会有这种行为 整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。 6.5.1. 最简单的分代式GC策略的触发条件 年轻代GC（Minor GC）触发机制 当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。） 因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。 Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行 老年代GC（Major GC / Full GC）触发机制 指发生在老年代的GC，对象从老年代消失时，我们说 “Major GC” 或 “Full GC” 发生了 出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程） 也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长 如果Major GC后，内存还不足，就报OOM了 Full GC触发机制（后面细讲）： 触发Full GC执行的情况有如下五种： 调用System.gc()时，系统建议执行Full GC，但是不必然执行 老年代空间不足 方法区空间不足 通过Minor GC后进入老年代的平均大小大于老年代的可用内存 由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小 说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些。 6.6. 堆空间分代思想 为什么要把Java堆分代？不分代就不能正常工作了吗？ 经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。 新生代：有Eden、两块大小相同的survivor（又称为from/to，s0/s1）构成，to总为空。 老年代：存放新生代中经历多次GC仍然存活的对象。 其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。 6.7. 内存分配策略 如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代。 对象晋升老年代的年龄阀值，可以通过选项-XX:MaxTenuringThreshold来设置 针对不同年龄段的对象分配原则如下所示： 优先分配到Eden 大对象直接分配到老年代（尽量避免程序中出现过多的大对象） 长期存活的对象分配到老年代 动态对象年龄判断：如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。 空间分配担保： -XX:HandlePromotionFailure 6.8. 为对象分配内存：TLAB 6.8.1. 为什么有TLAB（Thread Local Allocation Buffer）？ 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。 6.8.2. 什么是TLAB？ 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。 据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。 6.8.3. TLAB的再说明 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。 在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间。 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项 “-XX:TLABWasteTargetPercent” 设置TLAB空间所占用Eden空间的百分比大小。 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。 6.9. 小结：堆空间的参数设置 官网地址：https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html // 详细的参数内容会在JVM下篇：性能监控与调优篇中进行详细介绍，这里先熟悉下 -XX:+PrintFlagsInitial //查看所有的参数的默认初始值 -XX:+PrintFlagsFinal //查看所有的参数的最终值（可能会存在修改，不再是初始值） -Xms //初始堆空间内存（默认为物理内存的1/64） -Xmx //最大堆空间内存（默认为物理内存的1/4） -Xmn //设置新生代的大小。（初始值及最大值） -XX:NewRatio //配置新生代与老年代在堆结构的占比 -XX:SurvivorRatio //设置新生代中Eden和S0/S1空间的比例 -XX:MaxTenuringThreshold //设置新生代垃圾的最大年龄 -XX:+PrintGCDetails //输出详细的GC处理日志 //打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc -XX:HandlePromotionFalilure：//是否设置空间分配担保 -XX:SurvivorRatio //设置新生代中Eden和S0/S1空间的比例 Eden区设置过大时：s0/s1区很容易满，放入老年代，Minor GC失去意义，分代意义也更加弱 Eden区设置过小时：Minor GC出现频率变高，影响用户进程导致STW 在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。 如果大于，则此次Minor GC是安全的 如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允担保失败。 如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的； 如果小于，则改为进行一次Full GC。 如果HandlePromotionFailure=false，则改为进行一次Full Gc。 在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。 6.X. 堆是分配对象的唯一选择么？ 在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述： 随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。 此外，前面提到的基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。 6.X.1. 逃逸分析概述 如何将堆上的对象分配到栈，需要使用逃逸分析手段。 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。 逃逸分析的基本行为就是分析对象动态作用域： 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。 举例1 public void my_method() { V v = new V(); // use v // .... v = null; } 没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧 public static StringBuffer createStringBuffer(String s1, String s2) { StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb; } 上述方法如果想要StringBuffer sb不发生逃逸，可以这样写 public static String createStringBuffer(String s1, String s2) { StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb.toString(); } 举例2 public class EscapeAnalysis { public EscapeAnalysis obj; /** * 方法返回EscapeAnalysis对象，发生逃逸 * @return */ public EscapeAnalysis getInstance() { return obj == null ? new EscapeAnalysis() : obj; } /** * 为成员属性赋值，发生逃逸 */ public void setObj() { this.obj = new EscapeAnalysis(); } /** * 对象的作用于仅在当前方法中有效，没有发生逃逸 */ public void useEscapeAnalysis() { EscapeAnalysis e = new EscapeAnalysis(); } /** * 引用成员变量的值，发生逃逸 */ public void useEscapeAnalysis2() { EscapeAnalysis e = getInstance(); } } 参数设置 在JDK 6u23 版本之后，HotSpot中默认就已经开启了逃逸分析 如果使用的是较早的版本，开发人员则可以通过： 选项“-XX:+DoEscapeAnalysis\"显式开启逃逸分析 通过选项“-XX:+PrintEscapeAnalysis\"查看逃逸分析的筛选结果 结论：开发中能使用局部变量的，就不要使用在方法外定义。 6.X.2. 逃逸分析：代码优化 使用逃逸分析，编译器可以对代码做如下优化： 一、栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配 二、同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。 三、分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。 栈上分配 JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。 常见的指针逃逸的场景 在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。 同步省略 线程同步的代价是相当高的，同步的后果是降低并发性和性能。 在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。 举例 public void f() { Object hellis = new Object(); synchronized(hellis) { System.out.println(hellis); } } 代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成： public void f() { Object hellis = new Object(); System.out.println(hellis); } 字节码分析 /** * 同步省略说明 * @author xiexu * @create 2020-11-27 7:01 下午 */ public class SynchronizedTest { public void f() { Object hellis = new Object(); synchronized(hellis) { System.out.println(hellis); } } } 注意：字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，同步省略操作是在解释运行时发生的 标量替换 标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。 相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。 在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。 举例 public static void main(String args[]) { alloc(); } private static void alloc() { Point point = new Point(1,2); System.out.println(\"point.x\" + point.x + \";point.y\" + point.y); } class Point { private int x; private int y; } 以上代码，经过标量替换后，就会变成 private static void alloc() { int x = 1; int y = 2; System.out.println(\"point.x = \" + x + \"; point.y=\" + y); } 可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 标量替换为栈上分配提供了很好的基础。 标量替换参数设置 参数-XX:+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配到栈上。 /** * 标量替换测试 * -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations * @Author B.W.H * @Date 2022/2/23 0:08 */ public class ScalarReplace { public static class User{ public int id; public String name; } public static void alloc(){ User u = new User(); u.id = 5; u.name = \"www.atguigu.com\"; } public static void main(String[] args){ long start = System.currentTimeMillis(); for (int i = 0; i未开启标量替换 JVM 参数 -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations 日志分析：伴随着 GC 的垃圾回收，用时 47ms 开启标量替换 JVM 参数 -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations 日志分析：无垃圾回收，用时 5ms 未开启标量替换时，上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码： -server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations 这里设置参数如下： 参数-server：启动Server模式，因为在server模式下，才可以启用逃逸分析。 参数-XX:+DoEscapeAnalysis：启用逃逸分析 参数-Xmx10m：指定了堆空间最大为10MB 参数-XX:+PrintGC：将打印GC日志 参数-XX:+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配 6.X.3. 逃逸分析小结：逃逸分析并不成熟 关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。 其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。 虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。 注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。 目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。 本章小结 年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。 老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGC。 当GC发生在老年代时则被称为MajorGC或者FullGC。一般的，MinorGC的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。 "},"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/方法区.html":{"url":"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/方法区.html","title":"7.方法区","keywords":"","body":" 7. 方法区 7.1. 栈、堆、方法区的交互关系 7.2. 方法区的理解 7.2.1. 方法区在哪里？ 7.2.2. 方法区的基本理解 7.2.3. HotSpot中方法区的演进 7.3. 设置方法区大小与OOM 7.3.1. 设置方法区内存的大小 7.3.2. 如何解决这些OOM 7.4. 方法区的内部结构 7.4.1. 方法区（Method Area）存储什么？ 7.4.2. 方法区的内部结构 类型信息 域（Field）信息 方法（Method）信息 non-final的类变量 补充说明：全局常量（static final） 7.4.3. 运行时常量池 VS 常量池 为什么需要常量池？ 常量池中有什么? 小结 7.4.4. 运行时常量池 7.5. 方法区使用举例 7.6. 方法区的演进细节 7.6.1. 为什么永久代要被元空间替代？ 7.6.2. StringTable为什么要调整位置？ 7.6.3. 静态变量存放在那里？ 7.7. 方法区的垃圾回收 总结 常见面试题 7. 方法区 从线程共享与否的角度来看 7.1. 栈、堆、方法区的交互关系 7.2. 方法区的理解 官方文档：Chapter 2. The Structure of the Java Virtual Machine (oracle.com) 2.5.4.方法区 Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的方法区。方法区类似于传统语言的编译代码的存储区，或者类似于操作系统进程中的“文本”段。它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括类和实例初始化和接口初始化中使用的特殊方法（第 2.9 节）。 方法区是在虚拟机启动时创建的。尽管方法区在逻辑上是堆的一部分，但简单的实现可能会选择不进行垃圾收集或压缩它。本规范不要求方法区域的位置或用于管理已编译代码的策略。方法区域可以是固定大小，也可以根据计算需要扩大，如果不需要更大的方法区域，可以缩小。方法区的内存不需要是连续的。 Java 虚拟机实现可以为程序员或用户提供对方法区域初始大小的控制，以及在方法区域大小可变的情况下，对最大和最小方法区域大小的控制。 以下异常情况与方法区相关： 如果方法区域中的内存无法满足分配请求，Java 虚拟机将抛出 OutOfMemoryError。 7.2.1. 方法区在哪里？ 《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。 所以，方法区看作是一块独立于Java堆的内存空间。 7.2.2. 方法区的基本理解 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError: PermGen space 或者java.lang.OutOfMemoryError: Metaspace 加载大量的第三方的jar包；Tomcat部署的工程过多（30~50个）；大量动态的生成反射类 关闭JVM就会释放这个区域的内存。 7.2.3. HotSpot中方法区的演进 在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。 本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit / IBM J9 中不存在永久代的概念。 现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM（超过-XX:MaxPermsize上限） 而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存 永久代、元空间二者并不只是名字变了，内部结构也调整了 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常 7.3. 设置方法区大小与OOM 7.3.1. 设置方法区内存的大小 方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。 jdk7及以前 通过来设置永久代初始分配空间。默认值是20.75M-XX:Permsize 通过来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M-XX:MaxPermsize 当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGen space。 JDK8以后 元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定 默认值依赖于平台。windows下，-XX:MetaspaceSize=21M -XX:MaxMetaspaceSize=-1//即没有限制。 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace -XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。 OOM举例1：《深入理解Java虚拟机》的例子 OOM举例2 /** * jdk8中： * -XX:MetaspaceSize=10m-XX:MaxMetaspaceSize=10m * jdk6中： * -XX:PermSize=10m-XX:MaxPermSize=10m */ public class OOMTest extends ClassLoader{ public static void main(String[] args){ int j = 0; try{ OOMTest test = new OOMTest(); for (int i=0;i 7.3.2. 如何解决这些OOM 要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow） 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。 7.4. 方法区的内部结构 7.4.1. 方法区（Method Area）存储什么？ 《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下： 它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。 7.4.2. 方法区的内部结构 类型信息 对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息： 这个类型的完整有效名称（全名=包名.类名） 这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类） 这个类型的修饰符（public，abstract，final的某个子集） 这个类型直接接口的一个有序列表 域（Field）信息 JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。 域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集） 方法（Method）信息 JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序： 方法名称 方法的返回类型（或void） 方法参数的数量和类型（按顺序） 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集） 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外） 异常表（abstract和native方法除外） 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引 non-final的类变量 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分 类变量被类的所有实例共享，即使没有类实例时，你也可以访问它 public class MethodAreaTest { public static void main(String[] args) { Order order = new Order(); order.hello(); System.out.println(order.count); } } class Order { public static int count = 1; public static void hello() { System.out.println(\"hello!\"); } } 补充说明：全局常量（static final） 被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。 7.4.3. 运行时常量池 VS 常量池 方法区，内部包含了运行时常量池 字节码文件，内部包含了常量池 要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。 要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。 官方文档：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用 为什么需要常量池？ 一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。 比如：如下的代码： public class SimpleClass { public void sayHello() { System.out.println(\"hello\"); } } 虽然只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。 常量池中有什么? 击中常量池内存储的数据类型包括： 数量值 字符串值 类引用 字段引用 方法引用 例如下面这段代码： public class MethodAreaTest2 { public static void main(String args[]) { Object obj = new Object(); } } Object obj = new Object();将会被翻译成如下字节码 0: new #2 // Class java/lang/Object 1: dup 2: invokespecial // Method java/lang/Object \"\"() V 小结 常量池可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型 7.4.4. 运行时常量池 运行时常量池（Runtime Constant Pool）是方法区的一部分。 常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。 JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。 运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。 运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。 7.5. 方法区使用举例 public class MethodAreaDemo { public static void main(String args[]) { int x = 500; int y = 100; int a = x / y; int b = 50; System.out.println(a+b); } } 7.6. 方法区的演进细节 首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一 Hotspot中方法区的变化： JDK1.6及之前 有永久代（permanet），静态变量存储在永久代上 JDK1.7 有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中 JDK1.8 无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。 7.6.1. 为什么永久代要被元空间替代？ 官网地址：JEP 122: Remove the Permanent Generation (java.net) JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代 随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。 这项改动是很有必要的，原因有： 为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。 而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。 \"Exception in thread 'dubbo client x.x connector' java.lang.OutOfMemoryError:PermGen space\" 对永久代进行调优是很困难的。 有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。 方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型 7.6.2. StringTable为什么要调整位置？ jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。 7.6.3. 静态变量存放在那里？ /** * 静态引用对应的对象实体始终都存在堆空间 * jdk7: * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails * jdk8: * -Xms200m -Xmx200m-XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails */ public class StaticFieldTest { private static byte[] arr = new byte[1024 * 1024 * 100]; public static void main(String[] args) { System.out.println(StaticFieldTest.arr); try { Thread.sleep(1000000); } catch (InterruptedException e){ e.printStackTrace(); } } } /** * staticobj、instanceobj、Localobj存放在哪里？ */ public class StaticobjTest { static class Test { static ObjectHolder staticobj = new ObjectHolder(); ObjectHolder instanceobj = new ObjectHolder(); void foo(){ ObjectHolder localobj = new ObjectHolder(); System.out.println(\"done\"); } } private static class ObjectHolder{ public static void main(String[] args) { Test test = new StaticobjTest.Test(); test.foo(); } } } 使用JHSDB工具进行分析，这里细节略掉 staticobj随着Test的类型信息存放在方法区，instanceobj随着Test的对象实例存放在Java堆，localobject则是存放在foo()方法栈帧的局部变量表中。 测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例必然会在Java堆中分配。 接着，找到了一个引用该staticobj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段： 从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射class对象存放在一起，存储于Java堆之中，从我们的实验中也明确验证了这一点。 7.7. 方法区的垃圾回收 有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。 方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。 先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。 回收废弃常量与回收Java堆中的对象非常类似。 判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件： 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。 总结 常见面试题 百度： 说一下JVM内存模型吧，有哪些区？分别干什么的？ 蚂蚁金服： Java8的内存分代改进 JVM内存分哪几个区，每个区的作用是什么？ 一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？ 二面：Eden和survior的比例分配 小米： jvm内存分区，为什么要有新生代和老年代 字节跳动： 二面：Java的内存分区 二面：讲讲jvm运行时数据库区 什么时候对象会进入老年代？ 京东： JVM的内存结构，Eden和Survivor比例。 JVM内存为什么要分成新生代，老年代，持久代。 新生代中为什么要分为Eden和survivor。 天猫： 一面：Jvm内存模型以及分区，需要详细到每个区放什么。 一面：JVM的内存模型，Java8做了什么改 拼多多： JVM内存分哪几个区，每个区的作用是什么？ 美团： java内存分配 jvm的永久代中会发生垃圾回收吗？ 一面：jvm内存分区，为什么要有新生代和老年代？ "},"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/对象实例化及直接内存.html":{"url":"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/对象实例化及直接内存.html","title":"8.对象实例化及直接内存","keywords":"","body":" 8. 对象实例化及直接内存 8.1. 对象实例化 8.1.1. 创建对象的方式 8.1.2. 创建对象的步骤 1. 判断对象对应的类是否加载、链接、初始化 2. 为对象分配内存 3. 处理并发问题 4. 初始化分配到的内存 5. 设置对象的对象头 6. 执行init方法进行初始化 8.2. 对象内存布局 8.2.1. 对象头（Header） 运行时元数据 类型指针 8.2.2. 实例数据（Instance Data） 8.2.3. 对齐填充（Padding） 小结 8.3. 对象的访问定位 8.3.1. 句柄访问 8.3.2. 直接指针（HotSpot采用） 8.4. 直接内存（Direct Memory） 8.4.1. 直接内存概述 8.4.2. 非直接缓存区 8.4.3. 直接缓存区 8. 对象实例化及直接内存 8.1. 对象实例化 面试题 美团： 对象在JVM中是怎么存储的？ 对象头信息里面有哪些东西？ 蚂蚁金服： Java对象头有什么？ 8.1.1. 创建对象的方式 new：最常见的方式、Xxx的静态方法，XxxBuilder/XxxFactory的静态方法 Class的newInstance方法：反射的方式，只能调用空参的构造器，权限必须是public Constructor的newInstance(XXX)：反射的方式，可以调用空参、带参的构造器，权限没有要求 使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口，实现clone() 使用序列化：从文件中、从网络中获取一个对象的二进制流 第三方库 Objenesis 8.1.2. 创建对象的步骤 前面所述是从字节码角度看待对象的创建过程，现在从执行步骤的角度来分析： 1. 判断对象对应的类是否加载、链接、初始化 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。 如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件； 如果没有找到文件，则抛出ClassNotFoundException异常 如果找到，则进行类加载，并生成对应的Class对象 2. 为对象分配内存 首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小 如果内存规整：虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。 意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。 如果内存不规整：虚拟机需要维护一个空闲列表（Free List）来为对象分配内存。 已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。 3. 处理并发问题 采用CAS失败重试、区域加锁保证更新的原子性 每个线程预先分配一块TLAB：通过设置 -XX:+UseTLAB参数来设定 4. 初始化分配到的内存 所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用 5. 设置对象的对象头 将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。 6. 执行init方法进行初始化 在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。 因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。 给对象属性赋值的操作 属性的默认初始化 显式初始化 代码块中初始化 构造器中初始化 对象实例化的过程 加载类元信息 为对象分配内存 处理并发问题 属性的默认初始化（零值初始化） 设置对象头信息 属性的显示初始化、代码块中初始化、构造器中初始化 8.2. 对象内存布局 8.2.1. 对象头（Header） 对象头包含了两部分，分别是运行时元数据（Mark Word）和类型指针。如果是数组，还需要记录数组的长度 运行时元数据 哈希值（HashCode） GC分代年龄 锁状态标志 线程持有的锁 偏向线程ID 翩向时间戳 类型指针 指向类元数据InstanceKlass，确定该对象所属的类型。 8.2.2. 实例数据（Instance Data） 它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段） 相同宽度的字段总是被分配在一起 父类中定义的变量会出现在子类之前 如果CompactFields参数为true（默认为true）：子类的窄变量可能插入到父类变量的空隙 8.2.3. 对齐填充（Padding） 不是必须的，也没有特别的含义，仅仅起到占位符的作用（保证对象大小是8个字节的倍数） 举例 public class Customer{ int id = 1001; String name; Account acct; { name = \"匿名客户\"; } public Customer() { acct = new Account(); } } public class CustomerTest{ public static void main(string[] args){ Customer cust=new Customer(); } } 图示 小结 8.3. 对象的访问定位 JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？ 8.3.1. 句柄访问 reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改 8.3.2. 直接指针（HotSpot采用） 直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据 8.4. 直接内存（Direct Memory） 8.4.1. 直接内存概述 不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。直接内存是在Java堆外的、直接向系统申请的内存区间。来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存。通常，访问直接内存的速度会优于Java堆，即读写性能高。 因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。 Java的NIO库允许Java程序使用直接内存，用于数据缓冲区 8.4.2. 非直接缓存区 使用IO读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要两份内存存储重复数据，效率低。 8.4.3. 直接缓存区 使用NIO时，操作系统划出的直接缓存区可以被java代码直接访问，只有一份。NIO适合对大文件的读写操作。 也可能导致OutOfMemoryError异常 Exception in thread \"main\" java.lang.OutOfMemoryError: Direct buffer memory at java.nio.Bits.reserveMemory(Bits.java:693) at java.nio.DirectByteBuffer.(DirectByteBuffer.java:123) at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311) at com.atguigu.java.BufferTest2.main(BufferTest2.java:20) 由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。 分配回收成本较高 不受JVM内存回收管理 直接内存大小可以通过MaxDirectMemorySize设置。如果不指定，默认与堆的最大值-Xmx参数值一致 "},"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/执行引擎.html":{"url":"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/执行引擎.html","title":"9.执行引擎","keywords":"","body":" 9. 执行引擎 9.1. 执行引擎概述 9.1.1. 执行引擎的工作流程 9.2. Java代码编译和执行过程 9.2.1. 什么是解释器（Interpreter）？什么是JIT编译器？ 9.2.2. 为什么Java是半编译半解释型语言？ 9.3. 机器码、指令、汇编语言 9.3.1. 机器码 9.3.2. 指令 9.3.3. 指令集 9.3.4. 汇编语言 9.3.5. 高级语言 C、C++源程序执行过程 9.3.6. 字节码 9.4. 解释器 9.4.1. 解释器工作机制 9.4.2. 解释器分类 9.4.3. 现状 9.5. JIT编译器 9.5.1. Java代码的执行分类 9.5.2. HotSpot JVM执行方式 9.5.3. 概念解释 9.5.4. 热点代码及探测技术 方法调用计数器 热点衰减 回边计数器 9.5.5. HotSpotVM 可以设置程序执行方法 9.5.6. HotSpotVM中 JIT 分类 C1 和 C2编译器不同的优化策略 总结 写到最后1 写到最后2：AOT编译器 9. 执行引擎 9.1. 执行引擎概述 执行引擎属于JVM的下层，里面包括解释器、即时编译器、垃圾回收器 执行引擎是Java虚拟机核心的组成部分之一。 “虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。 JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。 那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。 9.1.1. 执行引擎的工作流程 执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。 每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。 从外观上来看，所有的Java虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。 9.2. Java代码编译和执行过程 大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤 Java代码编译是由Java源码编译器（前端编译器）来完成，流程图如下所示： Java字节码的执行是由JVM执行引擎（后端编译器）来完成，流程图 如下所示 9.2.1. 什么是解释器（Interpreter）？什么是JIT编译器？ 解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。 JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。 9.2.2. 为什么Java是半编译半解释型语言？ JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。 9.3. 机器码、指令、汇编语言 9.3.1. 机器码 各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。 机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。 用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。 机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。 9.3.2. 指令 由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。 指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好 由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。 9.3.3. 指令集 不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。 如常见的 x86指令集，对应的是x86架构的平台 ARM指令集，对应的是ARM架构的平台 9.3.4. 汇编语言 由于指令的可读性还是太差，于是人们又发明了汇编语言。 在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。 由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。 9.3.5. 高级语言 为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言 当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。 高级语言也不是直接翻译成机器指令，而是翻译成汇编语言码，如下面说的C和C++ C、C++源程序执行过程 编译过程又可以分成两个阶段：编译和汇编。 编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码 汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。 9.3.6. 字节码 字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码 字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。 字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。字节码典型的应用为：Java bytecode 9.4. 解释器 JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。 为什么Java源文件不直接翻译成机器指令，而是翻译成字节码文件？可能是因为直接翻译的代价是比较大的 9.4.1. 解释器工作机制 解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。 当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。 9.4.2. 解释器分类 在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。 字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。 而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。 在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。 Interpreter模块：实现了解释器的核心功能 Code模块：用于管理HotSpot VM在运行时生成的本地机器指令 9.4.3. 现状 由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。 为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。 不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。 9.5. JIT编译器 9.5.1. Java代码的执行分类 第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行 第二种是编译执行（直接编译成机器码，但是要知道不同机器上编译的机器码是不一样，而字节码是可以跨平台的）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行 HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。 在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++ 程序一较高下的地步。 问题来了 有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。 首先明确： 当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。 所以： 尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。 同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。 9.5.2. HotSpot JVM执行方式 当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。 案例来了 注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态可以承受的负载要大于冷机状态。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。 在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。 —阿里团队 9.5.3. 概念解释 Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程； 也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程。 还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。 前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。 JIT编译器：HotSpot VM的C1、C2编译器。 AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。 9.5.4. 热点代码及探测技术 当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为OSR（On Stack Replacement）编译。 一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。 采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。 方法调用计数器用于统计方法的调用次数 回边计数器则用于统计循环体执行的循环次数 方法调用计数器 这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。 这个阀值可以通过虚拟机参数 -XX:CompileThreshold来人为设定。 当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。 热点衰减 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time） 进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。 另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。 回边计数器 它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。 9.5.5. HotSpotVM 可以设置程序执行方法 缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示： -Xint：完全采用解释器模式执行程序； -Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行 -Xmixed：采用解释器+即时编译器的混合模式共同执行程序。 9.5.6. HotSpotVM中 JIT 分类 JIT的编译器还分为了两种，分别是C1和C2，在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示： -client：指定Java虚拟机运行在Client模式下，并使用C1编译器；C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。 -server：指定Java虚拟机运行在server模式下，并使用C2编译器。C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。 分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。 不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server\"时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。 C1 和 C2编译器不同的优化策略 在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联、去虚拟化、冗余消除。 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程 去虚拟化：对唯一的实现类进行内联 冗余消除：在运行期间把一些不会执行的代码折叠掉 C2的优化主要是在全局层面，逃逸分析（前面讲过，并不成熟）是优化的基础。基于逃逸分析在C2上有如下几种优化： 标量替换：用标量值代替聚合对象的属性值 栈上分配：对于未逃逸的对象分配对象在栈而不是堆 同步消除：清除同步操作，通常指synchronized 总结 一般来讲，JIT编译出来的机器码性能比解释器高。C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器 写到最后 写到最后1 自JDK10起，HotSpot又加入了一个全新的及时编译器：Graal编译器 编译效果短短几年时间就追评了C2编译器，未来可期 目前，带着实验状态标签，需要使用开关参数-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler去激活才能使用 写到最后2：AOT编译器 jdk9引入了AOT编译器（静态提前编译器，Ahead of Time Compiler） Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。 所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。 最大的好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验 缺点： 破坏了 java “ 一次编译，到处运行”的理念，必须为每个不同的硬件，OS编译对应的发行包 降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。 还需要继续优化中，最初只支持Linux X64 java base "},"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/StringTable.html":{"url":"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/StringTable.html","title":"10.StringTable","keywords":"","body":" 10. StringTable 10.1. String的基本特性 10.1.1. String在jdk9中存储结构变更 10.1.2. String的基本特性 10.2. String的内存分配 10.3. String的基本操作 10.4. 字符串拼接操作 10.5. intern()的使用 10.5.1. intern的使用：JDK6 vs JDK7/8 10.5.2. intern的效率测试：空间角度 10.6. StringTable的垃圾回收 10.7. G1中的String去重操作 10. StringTable 10.1. String的基本特性 String：字符串，使用一对\"\"引起来表示 String声明为final的，不可被继承 String实现了Serializable接口：表示字符串是支持序列化的。 String实现了Comparable接口：表示string可以比较大小 String在jdk8及以前内部定义了final char[] value用于存储字符串数据。JDK9时改为byte[] 10.1.1. String在jdk9中存储结构变更 官网地址：JEP 254: Compact Strings (java.net) Motivation The current implementation of the String class stores characters in a char array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused. Description We propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used. String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM's intrinsic string operations. This is purely an implementation change, with no changes to existing public interfaces. There are no plans to add any new public APIs or other interfaces. The prototyping work done to date confirms the expected reduction in memory footprint, substantial reductions of GC activity, and minor performance regressions in some corner cases. 动机 目前String类的实现将字符存储在一个char数组中，每个字符使用两个字节（16位）。从许多不同的应用中收集到的数据表明，字符串是堆使用的主要组成部分，此外，大多数字符串对象只包含Latin-1字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部字符数组中有一半的空间没有被使用。 说明 我们建议将String类的内部表示方法从UTF-16字符数组改为字节数组加编码标志域。新的String类将根据字符串的内容，以ISO-8859-1/Latin-1（每个字符一个字节）或UTF-16（每个字符两个字节）的方式存储字符编码。编码标志将表明使用的是哪种编码。 与字符串相关的类，如AbstractStringBuilder、StringBuilder和StringBuffer将被更新以使用相同的表示方法，HotSpot VM的内在字符串操作也是如此。 这纯粹是一个实现上的变化，对现有的公共接口没有变化。目前没有计划增加任何新的公共API或其他接口。 迄今为止所做的原型设计工作证实了内存占用的预期减少，GC活动的大幅减少，以及在某些角落情况下的轻微性能倒退。 结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间 public final class String implements java.io.Serializable, Comparable, CharSequence { @Stable private final byte[] value; } 10.1.2. String的基本特性 String：代表不可变的字符序列。简称：不可变性。 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 当调用string的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。 字符串常量池是不会存储相同内容的字符串的 String的String Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降。 使用-XX:StringTablesize可设置StringTable的长度 在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTablesize设置没有要求 在jdk7中，StringTable的长度默认值是60013，StringTablesize设置没有要求 在JDK8中，设置StringTable长度的话，1009是可以设置的最小值 10.2. String的内存分配 在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。 常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。 直接使用双引号声明出来的String对象会直接存储在常量池中。 如果不是用双引号声明的String对象，可以使用String提供的intern()方法。这个后面重点谈 Java 6及以前，字符串常量池存放在永久代 Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内 所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。 字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。 Java 8元空间，字符串常量在堆 StringTable为什么要调整？ 官网地址：Java SE 7 Features and Enhancements (oracle.com) Synopsis: In JDK 7, interned strings are no longer allocated in the permanent generation of the Java heap, but are instead allocated in the main part of the Java heap (known as the young and old generations), along with the other objects created by the application. This change will result in more data residing in the main Java heap, and less data in the permanent generation, and thus may require heap sizes to be adjusted. Most applications will see only relatively small differences in heap usage due to this change, but larger applications that load many classes or make heavy use of the String.intern() method will see more significant differences. 简介：在JDK 7中，内部字符串不再分配在Java堆的永久代中，而是分配在Java堆的主要部分（称为年轻代和老年代），与应用程序创建的其他对象一起。这种变化将导致更多的数据驻留在主Java堆中，而更少的数据在永久代中，因此可能需要调整堆的大小。大多数应用程序将看到由于这一变化而导致的堆使用的相对较小的差异，但加载许多类或大量使用String.intern()方法的大型应用程序将看到更明显的差异。 10.3. String的基本操作 public class StringTest { public static void main(String[] args) { System.out.println(); System.out.println(\"1\"); //2166 System.out.println(\"2\"); System.out.println(\"3\"); System.out.println(\"4\"); System.out.println(\"5\"); System.out.println(\"6\"); System.out.println(\"7\"); System.out.println(\"8\"); System.out.println(\"9\"); System.out.println(\"10\"); //2175 System.out.println(\"1\"); //2176 System.out.println(\"2\"); //2176 System.out.println(\"3\"); System.out.println(\"4\"); System.out.println(\"5\"); System.out.println(\"6\"); System.out.println(\"7\"); System.out.println(\"8\"); System.out.println(\"9\"); System.out.println(\"10\");//2176 } } Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。 class Memory { public static void main(String[] args) {//line 1 int i= 1;//line 2 Object obj = new Object();//line 3 Memory mem = new Memory();//Line 4 mem.foo(obj);//Line 5 }//Line 9 private void foo(Object param) {//line 6 String str = param.toString();//line 7 System.out.println(str); }//Line 8 } 10.4. 字符串拼接操作 常量与常量的拼接结果在常量池，原理是编译期优化 常量池中不会存在相同内容的变量 只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder 如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址 举例1 @Test public void test1() { // 都是常量，前端编译期会进行代码优化 // 通过idea直接看对应的反编译的class文件，会显示 String s1 = \"abc\"; 说明做了代码优化 String s1 = \"a\" + \"b\" + \"c\"; String s2 = \"abc\"; // true，有上述可知，s1和s2实际上指向字符串常量池中的同一个值 System.out.println(s1 == s2);//true } 举例2 @Test public static void test2() { String s1 = \"javaEE\"; String s2 = \"hadoop\"; String s3 = \"javaEEhadoop\"; String s4 = \"javaEE\" + \"hadoop\"; String s5 = s1 + \"hadoop\"; String s6 = \"javaEE\" + s2; String s7 = s1 + s2; System.out.println(s3 == s4); // true 编译期优化 System.out.println(s3 == s5); // false s1是变量，不能编译期优化 System.out.println(s3 == s6); // false s2是变量，不能编译期优化 System.out.println(s3 == s7); // false s1、s2都是变量 System.out.println(s5 == s6); // false s5、s6 不同的对象实例 System.out.println(s5 == s7); // false s5、s7 不同的对象实例 System.out.println(s6 == s7); // false s6、s7 不同的对象实例 String s8 = s6.intern(); System.out.println(s3 == s8); // true intern之后，s8和s3一样，指向字符串常量池中的\"javaEEhadoop\" } 举例3 @Test public void test3(){ String s1 = \"a\"; String s2 = \"b\"; String s3 = \"ab\"; String s4 = s1 + s2; System.out.println(s3==s4);//false } 举例4 @Test public void test4(){ final String s1 = \"a\"; final String s2 = \"b\"; String s3 = \"ab\"; String s4 = s1 + s2; System.out.println(s3==s4);//true } 举例5 public void test6(){ String s0 = \"beijing\"; String s1 = \"bei\"; String s2 = \"jing\"; String s3 = s1 + s2; System.out.println(s0 == s3); // false s3指向对象实例，s0指向字符串常量池中的\"beijing\" String s7 = \"shanxi\"; final String s4 = \"shan\"; final String s5 = \"xi\"; String s6 = s4 + s5; System.out.println(s6 == s7); // true s4和s5是final修饰的，编译期就能确定s6的值了 } 不使用final修饰，即为变量。如s3行的s1和s2，会通过new StringBuilder进行拼接 使用final修饰，即为常量。会在编译器进行代码优化。在实际开发中，能够使用final的，尽量使用 字节码 我们拿例3的字节码进行查看，可以发现s1 + s2实际上是new了一个StringBuilder对象，并使用了append方法将s1和s2添加进来，最后调用了toString方法赋给s4 0 ldc #19 2 astore_1 3 ldc #20 5 astore_2 6 ldc #21 8 astore_3 9 new #8 12 dup 13 invokespecial #9 : ()V> 16 aload_1 17 invokevirtual #10 20 aload_2 21 invokevirtual #10 24 invokevirtual #11 27 astore 4 29 getstatic #3 32 aload_3 33 aload 4 35 if_acmpne 42 (+7) 38 iconst_1 39 goto 43 (+4) 42 iconst_0 43 invokevirtual #4 46 return 字符串拼接操作性能对比 public class Test { public static void main(String[] args) { int times = 50000; // String long start = System.currentTimeMillis(); testString(times); long end = System.currentTimeMillis(); System.out.println(\"String: \" + (end-start) + \"ms\"); // StringBuilder start = System.currentTimeMillis(); testStringBuilder(times); end = System.currentTimeMillis(); System.out.println(\"StringBuilder: \" + (end-start) + \"ms\"); // StringBuffer start = System.currentTimeMillis(); testStringBuffer(times); end = System.currentTimeMillis(); System.out.println(\"StringBuffer: \" + (end-start) + \"ms\"); } public static void testString(int times) { String str = \"\"; for (int i = 0; i 本实验进行5万次循环，String拼接方式的时间是StringBuilder.append方式的约4000倍，StringBuffer.append()方式的时间是StringBuilder.append()方式的约2倍 可以看到，通过StringBuilder的append方式的速度，要比直接对String使用“+”拼接的方式快的不是一点半点 那么，在实际开发中，对于需要多次或大量拼接的操作，在不考虑线程安全问题时，我们就应该尽可能使用StringBuilder进行append操作。 除此之外，还有那些操作能够帮助我们提高字符串方面的运行效率呢？ StringBuilder空参构造器的初始化大小为16。那么，如果提前知道需要拼接String的个数，就应该直接使用带参构造器指定capacity，以减少扩容的次数（扩容的逻辑可以自行查看源代码） /** * Constructs a string builder with no characters in it and an * initial capacity of 16 characters. */ public StringBuilder() { super(16); } /** * Constructs a string builder with no characters in it and an * initial capacity specified by the {@code capacity} argument. * * @param capacity the initial capacity. * @throws NegativeArraySizeException if the {@code capacity} * argument is less than {@code 0}. */ public StringBuilder(int capacity) { super(capacity); } 10.5. intern()的使用 官方API文档中的解释 public String intern() Returns a canonical representation for the string object. A pool of strings, initially empty, is maintained privately by the class String. When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned. It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true. All literal strings and string-valued constant expressions are interned. String literals are defined in section 3.10.5 of the The Java™ Language Specification. Returns: a string that has the same contents as this string, but is guaranteed to be from a pool of unique strings. 当调用intern方法时，如果池子里已经包含了一个与这个String对象相等的字符串，正如equals(Object)方法所确定的，那么池子里的字符串会被返回。否则，这个String对象被添加到池中，并返回这个String对象的引用。 由此可见，对于任何两个字符串s和t，当且仅当s.equals(t)为真时，s.intern() == t.intern()为真。 所有字面字符串和以字符串为值的常量表达式都是interned。 返回一个与此字符串内容相同的字符串，但保证是来自一个唯一的字符串池。 intern是一个native方法，调用的是底层C的方法 /** * Returns a canonical representation for the string object. * * A pool of strings, initially empty, is maintained privately by the * class {@code String}. * * When the intern method is invoked, if the pool already contains a * string equal to this {@code String} object as determined by * the {@link #equals(Object)} method, then the string from the pool is * returned. Otherwise, this {@code String} object is added to the * pool and a reference to this {@code String} object is returned. * * It follows that for any two strings {@code s} and {@code t}, * {@code s.intern() == t.intern()} is {@code true} * if and only if {@code s.equals(t)} is {@code true}. * * All literal strings and string-valued constant expressions are * interned. String literals are defined in section 3.10.5 of the * The Java&trade; Language Specification. * * @return a string that has the same contents as this string, but is * guaranteed to be from a pool of unique strings. */ public native String intern(); 如果不是用双引号声明的String对象，可以使用String提供的intern方法，它会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。 String myInfo = new string(\"I love atguigu\").intern(); 也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true (\"a\"+\"b\"+\"c\").intern() == \"abc\" 通俗点讲，Interned string就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool） 10.5.1. intern的使用：JDK6 vs JDK7/8 /** * ① String s = new String(\"1\") * 创建了两个对象 * 堆空间中一个new对象 * 字符串常量池中一个字符串常量\"1\"（注意：此时字符串常量池中已有\"1\"） * ② s.intern()由于字符串常量池中已存在\"1\" * * s 指向的是堆空间中的对象地址 * s2 指向的是堆空间中常量池中\"1\"的地址 * 所以不相等 */ String s = new String(\"1\"); s.intern(); String s2 = \"1\"; System.out.println(s==s2); // jdk1.6 false jdk7/8 false /* * ① String s3 = new String(\"1\") + new String(\"1\") * 等价于new String（\"11\"），但是，常量池中并不生成字符串\"11\"； * * ② s3.intern() * 由于此时常量池中并无\"11\"，所以把s3中记录的对象的地址存入常量池 * 所以s3 和 s4 指向的都是一个地址 */ String s3 = new String(\"1\") + new String(\"1\"); s3.intern(); String s4 = \"11\"; System.out.println(s3==s4); //jdk1.6 false jdk7/8 true 总结String的intern()的使用： JDK1.6中，将这个字符串对象尝试放入串池。 如果串池中有，则并不会放入。返回已有的串池中的对象的地址 如果没有，会把此对象复制一份，放入串池，并返回串池中的对象地址 JDK1.7起，将这个字符串对象尝试放入串池。 如果串池中有，则并不会放入。返回已有的串池中的对象的地址 如果没有，则会把对象的引用地址复制一份，放入串池，并返回串池中的引用地址 练习1 练习2 10.5.2. intern的效率测试：空间角度 我们通过测试一下，使用了intern和不使用的时候，其实相差还挺多的 public class StringIntern2 { static final int MAX_COUNT = 1000 * 10000; static final String[] arr = new String[MAX_COUNT]; public static void main(String[] args) { Integer [] data = new Integer[]{1,2,3,4,5,6,7,8,9,10}; long start = System.currentTimeMillis(); for (int i = 0; i 结论：对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用intern()方法能够节省内存空间。 大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern()方法，就会很明显降低内存的大小。 10.6. StringTable的垃圾回收 public class StringGCTest { /** * -Xms15m -Xmx15m -XX:+PrintGCDetails */ public static void main(String[] args) { for (int i = 0; i [GC (Allocation Failure) [PSYoungGen: 4096K->488K(4608K)] 4096K->684K(15872K), 0.0017277 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap PSYoungGen total 4608K, used 3701K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000) eden space 4096K, 78% used [0x00000000ffb00000,0x00000000ffe237d8,0x00000000fff00000) from space 512K, 95% used [0x00000000fff00000,0x00000000fff7a020,0x00000000fff80000) to space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen total 11264K, used 196K [0x00000000ff000000, 0x00000000ffb00000, 0x00000000ffb00000) object space 11264K, 1% used [0x00000000ff000000,0x00000000ff031010,0x00000000ffb00000) Metaspace used 3306K, capacity 4496K, committed 4864K, reserved 1056768K class space used 359K, capacity 388K, committed 512K, reserved 1048576K 10.7. G1中的String去重操作 官网地址：JEP 192: String Deduplication in G1 (java.net) Motivation Many large-scale Java applications are currently bottlenecked on memory. Measurements have shown that roughly 25% of the Java heap live data set in these types of applications is consumed by String objects. Further, roughly half of those String objects are duplicates, where duplicates means string1.equals(string2) is true. Having duplicate String objects on the heap is, essentially, just a waste of memory. This project will implement automatic and continuous String deduplication in the G1 garbage collector to avoid wasting memory and reduce the memory footprint. 目前，许多大规模的Java应用程序在内存上遇到了瓶颈。测量表明，在这些类型的应用程序中，大约25%的Java堆实时数据集被String'对象所消耗。此外，这些 \"String \"对象中大约有一半是重复的，其中重复意味着 \"string1.equals(string2) \"是真的。在堆上有重复的String'对象，从本质上讲，只是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动和持续的`String'重复数据删除，以避免浪费内存，减少内存占用。 注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复 背景：对许多Java应用（有大的也有小的）做的测试得出以下结果： 堆存活数据集合里面string对象占了25% 堆存活数据集合里面重复的string对象有13.5% string对象的平均长度是45 许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半string对象是重复的，重复的意思是说： stringl.equals(string2)= true。堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的string对象进行去重，这样就能避免浪费内存。 实现 当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。 如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的string对象。 使用一个hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。 如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。 如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。 命令行选项 # 开启String去重，默认是不开启的，需要手动开启。 UseStringDeduplication(bool) # 打印详细的去重统计信息 PrintStringDeduplicationStatistics(bool) # 达到这个年龄的String对象被认为是去重的候选对象 StringpeDuplicationAgeThreshold(uintx) "},"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/垃圾回收概述及算法.html":{"url":"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/垃圾回收概述及算法.html","title":"11.垃圾回收概述及算法","keywords":"","body":" 11. 垃圾回收概述及算法 11.1. 垃圾回收概述 11.1.1. 什么是垃圾？ 什么是垃圾？ 11.1.2. 为什么需要GC 11.1.3. 早期垃圾回收 11.1.4. Java垃圾回收机制 担忧 GC主要关注的区域 11.2. 垃圾回收相关算法 11.2.1. 标记阶段：引用计数算法 方式一：引用计数算法 循环引用 小结 11.2.2. 标记阶段：可达性分析算法 可达性分析算法（根搜索算法、追踪性垃圾收集） 基本思路 11.2.3. 对象的finalization机制 生存还是死亡？ 具体过程 11.2.4. MAT与JProfiler的GC Roots溯源 MAT是什么？ 获取dump文件 方式一：命令行使用 jmap 方式二：使用JVisualVM导出 使用MAT打开Dump文件 JProfiler的GC Roots溯源 11.2.5. 清除阶段：标记-清除算法 标记-清除算法（Mark-Sweep） 执行过程 缺点 何为清除？ 11.2.6. 清除阶段：复制算法 复制（Copying）算法 核心思想 优点 缺点 特别的 应用场景 image-20220226235824934 11.2.7. 清除阶段：标记-压缩（整理）算法 标记-压缩（或标记-整理、Mark-Compact）算法 执行过程 指针碰撞（Bump the Pointer） 优点 缺点 11.2.8. 小结 11.2.9. 分代收集算法 年轻代（Young Gen） 老年代（Tenured Gen） 11.2.X. 增量收集算法、分区算法 增量收集算法 基本思想 缺点 分区算法 写到最后 11. 垃圾回收概述及算法 11.1. 垃圾回收概述 11.1.1. 什么是垃圾？ 垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。 关于垃圾收集有三个经典问题： 哪些内存需要回收？ 什么时候回收？ 如何回收？ 垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。 大厂面试题 蚂蚁金服 你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和G1？ JVM GC算法有哪些，目前的JDK版本采用什么回收算法？ G1回收器讲下回收过程GC是什么？为什么要有GC？ GC的两种判定方法？CMS收集器与G1收集器的特点 百度 说一下GC算法，分代回收说下 垃圾收集策略和算法 天猫 JVM GC原理，JVM怎么回收内存 CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？ 滴滴 Java的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃圾回收器的 京东 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1， 包括原理，流程，优缺点。垃圾回收算法的实现原理 阿里 讲一讲垃圾回收算法。 什么情况下触发垃圾回收？ 如何选择合适的垃圾收集算法？ JVM有哪三种垃圾回收器？ 字节跳动 常见的垃圾回收器算法有哪些，各有什么优劣？ System.gc（）和Runtime.gc（）会做什么事情？ Java GC机制？GC Roots有哪些？ Java对象的回收方式，回收算法。 CMS和G1了解么，CMS解决什么问题，说一下回收的过程。 CMS回收停顿了几次，为什么要停顿两次? 什么是垃圾？ An object is considered garbage when it can no longer be reached from any pointer in the running program 垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。 如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。 磁盘碎片整理的日子 机械硬盘需要进行磁盘整理，同时还有坏道 11.1.2. 为什么需要GC 想要学习GC，首先需要理解为什么需要GC？ 对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。 随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。 11.1.3. 早期垃圾回收 在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码： MibBridge *pBridge= new cmBaseGroupBridge(); //如果注册失败，使用Delete释放该对象所占内存区域 if (pBridge->Register(kDestroy) != NO ERROR） delete pBridge; 这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。 在有了垃圾回收机制后，上述代码极有可能变成这样 MibBridge *pBridge = new cmBaseGroupBridge(); pBridge->Register(kDestroy); 现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了线代开发语言必备的标准。 11.1.4. Java垃圾回收机制 自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险 没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。 自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发 oracle官网关于垃圾回收的介绍 https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html 担忧 对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。 此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见outofMemoryError时，快速地根据错误异常日志定位问题和解决问题。 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。 GC主要关注的区域 GC主要关注于 方法区 和堆中的垃圾收集 垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收。其中，Java堆是垃圾收集器的工作重点 从次数上讲： 频繁收集Young区 较少收集Old区 基本不收集Perm区（元空间） 11.2. 垃圾回收相关算法 对象存活判断 在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。 那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。 判断对象存活一般有两种方式：引用计数算法和可达性分析算法。 11.2.1. 标记阶段：引用计数算法 方式一：引用计数算法 引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。 优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。 缺点： 它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。 循环引用 当p的指针断开的时候，内部的引用形成一个循环，这就是循环引用 举例 测试Java中是否采用的是引用计数算法 public class RefCountGC { // 这个成员属性的唯一作用就是占用一点内存 private byte[] bigSize = new byte[5*1024*1024]; // 引用 Object reference = null; public static void main(String[] args) { RefCountGC obj1 = new RefCountGC(); RefCountGC obj2 = new RefCountGC(); obj1.reference = obj2; obj2.reference = obj1; obj1 = null; obj2 = null; // 显示的执行垃圾收集行为 // 这里发生GC，obj1和obj2是否被回收？ //System.gc(); } } public class RefCountGC { // 这个成员属性的唯一作用就是占用一点内存 private byte[] bigSize = new byte[5*1024*1024];//5MB // 引用 Object reference = null; public static void main(String[] args) { RefCountGC obj1 = new RefCountGC(); RefCountGC obj2 = new RefCountGC(); obj1.reference = obj2; obj2.reference = obj1; obj1 = null; obj2 = null; // 显示的执行垃圾收集行为 // 这里发生GC，obj1和obj2是否被回收？ System.gc(); } } 上述进行了GC收集的行为，所以可以证明JVM中采用的不是引用计数器的算法 小结 引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。 具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。 Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。 Python如何解决循环引用？ 手动解除：很好理解，就是在合适的时机，解除引用关系。 使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。 11.2.2. 标记阶段：可达性分析算法 可达性分析算法（根搜索算法、追踪性垃圾收集） 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。 相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection） 所谓\"GCRoots”根集合就是一组必须活跃的引用。 基本思路 可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain） 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。 在Java语言中，GC Roots包括以下几类元素： 虚拟机栈中引用的对象 比如：各个线程被调用的方法中使用到的参数、局部变量等。 本地方法栈内JNI（通常说的本地方法）引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 比如：字符串常量池（String Table）里的引用 所有被同步锁synchronized持有的对象 Java虚拟机内部的引用。 基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（PartialGC）。 如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GCRoots集合中去考虑，才能保证可达性分析的准确性。 小技巧：由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。 即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。 11.2.3. 对象的finalization机制 Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。 finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。 永远不要主动调用某个对象的finalize()方法I应该交给垃圾回收机制调用。理由包括下面三点： 在finalize()时可能会导致对象复活。 finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。 一个糟糕的finalize()会严重影响Gc的性能。 从功能上来说，finalize()方法与C中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C中的析构函数。 由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。 生存还是死亡？ 如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下： 可触及的：从根节点开始，可以到达这个对象。 可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。 不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。 以上3种状态中，是由于inalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。 具体过程 判定一个对象objA是否可回收，至少要经历两次标记过程： 如果对象objA到GC Roots没有引用链，则进行第一次标记。 进行筛选，判断此对象是否有必要执行finalize()方法 如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。 如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。 finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。 举例 public class CanReliveObj { public static CanReliveObj obj; @Override protected void finalize() throws Throwable { super.finalize(); System.out.println(\"调用当前类重写的finalize()方法\" + this); obj = this; } public static void main(String[] args) { try { obj = new CanReliveObj(); System.out.println(obj); obj = null; System.gc();//调用垃圾回收器 System.out.println(\"第一次gc\"); Thread.sleep(2000); if(obj == null){ System.out.println(\"obj is dead\"); }else { System.out.println(obj); System.out.println(\"obj is still alive\"); } System.out.println(\"第2次gc\"); obj = null; System.gc(); Thread.sleep(2000); if(obj == null){ System.out.println(\"obj is dead\"); }else { System.out.println(obj); System.out.println(\"obj is still alive\"); } }catch (InterruptedException e){ e.printStackTrace(); } } } 运行结果 com.huahua.java.CanReliveObj@1b6d3586 第一次gc 调用当前类重写的finalize()方法com.huahua.java.CanReliveObj@1b6d3586 com.huahua.java.CanReliveObj@1b6d3586 obj is still alive 第2次gc obj is dead 在第一次GC时，执行了finalize方法，但finalize()方法只会被调用一次，所以第二次该对象被GC标记并清除了。 11.2.4. MAT与JProfiler的GC Roots溯源 MAT是什么？ MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。 MAT是基于Eclipse开发的，是一款免费的性能分析工具。 大家可以在 http://www.eclipse.org/mat/ 下载并使用MAT 获取dump文件 方式一：命令行使用 jmap 方式二：使用JVisualVM导出 捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。 可通过以下方法捕获heap dump： 在左侧“Application\"（应用程序）子窗口中右击相应的应用程序，选择Heap Dump（堆Dump）。 在Monitor（监视）子标签页中点击Heap Dump（堆Dump）按钮。 本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump在左侧的Application（应用程序）栏中对应一个含有时间戳的节点。 右击这个节点选择save as（另存为）即可将heap dump保存到本地。 使用MAT打开Dump文件 JProfiler的GC Roots溯源 我们在实际的开发中，一般不会查找全部的GC Roots，可能只是查找某个对象的整个链路，或者称为GC Roots溯源，这个时候，我们就可以使用JProfiler 11.2.5. 清除阶段：标记-清除算法 当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。 目前在JVM中比较常见的三种垃圾收集算法是标记一清除算法（Mark-Sweep）、复制算法（copying）、标记-压缩算法（Mark-Compact） 标记-清除算法（Mark-Sweep） 标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。 执行过程 当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收 缺点 标记清除算法的效率不算高 在进行GC的时候，需要停止整个应用程序，用户体验较差 这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表 何为清除？ 这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。 11.2.6. 清除阶段：复制算法 复制（Copying）算法 为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。 核心思想 将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。 优点 没有标记和清除过程，实现简单，运行高效（补充：复制的算法需要获取的是哪些是有用的，也就是说可达性分析的过程中已经完成了筛选，分析过程中就可以将这一部分内容复制到另一半空间中，然后把原来的一半空间完全清除就可以了，没有标记的必要。） 复制过去以后保证空间的连续性，不会出现“碎片”问题。 缺点 此算法的缺点也是很明显的，就是需要两倍的内存空间。 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小 特别的 如果系统中的存活对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行。 应用场景 在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。 11.2.7. 清除阶段：标记-压缩（整理）算法 标记-压缩（或标记-整理、Mark-Compact）算法 复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。 标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。 1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。 执行过程 第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。 之后，清理边界外所有的空间。 标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。 二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 指针碰撞（Bump the Pointer） 如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump tHe Pointer）。 优点 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。 消除了复制算法当中，内存减半的高额代价。 缺点 从效率上来说，标记-整理算法要低于复制算法。 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址 移动过程中，需要全程暂停用户应用程序。即：STW 11.2.8. 小结 Mark-Sweep(标记清除) Mark-Compact（标记整理） Copying（复制） 速率 中等 最慢 最快 空间开销 少（但会堆积碎片） 少（不堆积碎片） 通常需要活对象的2倍空间（不堆积碎片） 移动对象 否 是 是 效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。 而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段 难道就没有一种最优算法吗？ 回答：无，没有最好的算法，只有最合适的算法。 11.2.9. 分代收集算法 前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。 分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。 在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。目前几乎所有的GC都采用分代手机算法执行垃圾回收的。 在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。 年轻代（Young Gen） 年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。 这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。 老年代（Tenured Gen） 老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。 这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。 Mark阶段的开销与存活对象的数量成正比。 Sweep阶段的开销与所管理区域的大小成正相关。 Compact阶段的开销与存活对象的数据成正比。 以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。 分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代 11.2.X. 增量收集算法、分区算法 增量收集算法 上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在Stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生 基本思想 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。 总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作 缺点 使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。 分区算法 一般来说，在相同条件下，堆空间越大，一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。 分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。 写到最后 注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。 "},"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/垃圾回收相关概念.html":{"url":"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/垃圾回收相关概念.html","title":"12.垃圾回收相关概念","keywords":"","body":" 12. 垃圾回收相关概念 12.1. System.gc()的理解 12.2. 内存溢出与内存泄露 内存溢出（OOM） 内存泄漏（Memory Leak） 12.3. Stop The World 12.4. 垃圾回收的并行与并发 并发（Concurrent） 并行（Parallel） 并发 vs 并行 垃圾回收的并发与并行 并行（Parallel） 串行（Serial） 并发（Concurrent） 12.5. 安全点与安全区域 安全点 抢先式中断：（目前没有虚拟机采用了） 主动式中断 安全区域（Safe Region） 实际执行时： 12.6. 再谈引用：强引用 强引用（Strong Reference）——不回收 12.8. 再谈引用： 软引用 软引用（Soft Reference）——内存不足即回收 12.9. 再谈引用：弱引用 弱引用（Weak Reference）——发现即回收 12.X. 再谈引用：虚引用 虚引用（Phantom Reference）——对象回收跟踪 12.11. 终结器引用 12. 垃圾回收相关概念 12.1. System.gc()的理解 在默认情况下，通过system.gc()或者Runtime.getRuntime().gc() 的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。 然而System.gc() 调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效) JVM实现者可以通过System.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc() public class SystemGCTest { public static void main(String[] args) { new SystemGCTest(); System.gc();// 提醒JVM的垃圾回收器执行gc，但是不确定是否马上执行gc // 与Runtime.getRuntime().gc();的作用一样 System.runFinalization();//强制执行使用引用的对象的finalize()方法 } @Override protected void finalize() throws Throwable { super.finalize(); System.out.println(\"SystemGCTest 重写了finalize()\"); } } 12.2. 内存溢出与内存泄露 内存溢出（OOM） 内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。 由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。 大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。 javadoc中对OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。 首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二： Java虚拟机的堆内存设置不够。 比如： 可能存在内存泄漏问题； 也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用） 对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以 当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError: PermGen space\"。 随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace\"。直接内存不足，也会导致OOM。 这里面隐含着一层意思是，在抛出OutOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。 例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。 在java.nio.Bits.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。 当然，也不是在任何情况下垃圾收集器都会被触发的 比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutOfMemoryError。 内存泄漏（Memory Leak） 也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。 但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。 尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutOfMemory异常，导致程序崩溃。 注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。 举例 单例模式 单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。 一些提供close的资源未关闭导致内存泄漏 数据库连接（dataSourse.getConnection() ），网络连接（socket）和io连接必须手动close，否则是不能被回收的。 12.3. Stop The World Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。 可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。 分析工作必须在一个能确保一致性的快照中进行 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证 被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。 STW事件和采用哪款GC无关，所有的GC都有这个事件。 哪怕是G1也不能完全避免Stop-the-World情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。 STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。 开发中不要用System.gc() 会导致Stop-the-World的发生。 12.4. 垃圾回收的并行与并发 并发（Concurrent） 在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。 并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。 并行（Parallel） 当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Parallel）。 其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。 适合科学计算，后台处理等弱交互场景 并发 vs 并行 并发，指的是多个事情，在同一时间段内同时发生了 并行，指的是多个事情，在同一时间点上同时发生了。 并发的多个任务之间是互相抢占资源的。 并行的多个任务之间是不互相抢占资源的。 只有在多CPU或者一个CPU多核的情况中，才会发生并行。 否则，看似同时发生的事情，其实都是并发执行的。 垃圾回收的并发与并行 并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下： 并行（Parallel） 指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如ParNew、Parallel Scavenge、Parallel Old； 串行（Serial） 相较于并行的概念，单线程执行。如果内存不够，则程序暂停，启动JM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。 并发（Concurrent） 指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；如：CMS、G1 12.5. 安全点与安全区域 安全点 程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为\"安全点（Safepoint）\"。 Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。 如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？ 抢先式中断：（目前没有虚拟机采用了） 首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。 主动式中断 设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制） 安全区域（Safe Region） Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？例如线程处于Sleep 状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。 实际执行时： 当线程运行到Safe Region的代码时，首先标识已经进入了Safe Relgion，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程; 当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止； 12.6. 再谈引用：强引用 我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。 【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？ 在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）这4种引用强度依次逐渐减弱。 除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。 Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用 强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj = new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。 软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。 弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。 虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 强引用（Strong Reference）——不回收 在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。 当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。 对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。 相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。 强引用例子 StringBuffer str = new StringBuffer(\"hello mogublog\"); 局部变量str指向StringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是StringBuffer实例的强引用 对应的内存结构 此时，如果再运行一个赋值语句 StringBuffer str1 = str; 对应的内存结构 本例中的两个引用，都是强引用，强引用具备以下特点： 强引用可以直接访问目标对象。 强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。 强引用可能导致内存泄漏。 12.8. 再谈引用： 软引用 软引用（Soft Reference）——内存不足即回收 软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。 软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存 垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。 类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。 在JDK1.2版之后提供了java.lang.ref.SoftReference类来实现软引用 Object obj = new Object(); // 声明强引用 SoftReference sf = new SoftReference<>(obj); obj = null; //销毁强引用 12.9. 再谈引用：弱引用 弱引用（Weak Reference）——发现即回收 弱引用也是用来描述那些非必需对象，只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。 但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。 弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。 在JDK1.2版之后提供了WeakReference类来实现弱引用 Object obj = new Object(); // 声明强引用 WeakReference sf = new WeakReference<>(obj); obj = null; //销毁强引用 弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。 面试题：你开发中使用过WeakHashMap吗？ WeakHashMap用来存储图片信息，可以在内存不足的时候，及时回收，避免了OOM 12.X. 再谈引用：虚引用 虚引用（Phantom Reference）——对象回收跟踪 也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。 一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。 它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null 为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。 虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。 由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。 在JDK1.2版之后提供了PhantomReference类来实现虚引用。 Object obj = new Object(); // 声明强引用 ReferenceQueue phantomQueue = new ReferenceQueue(); PhantomReference sf = new PhantomReference<>(obj, phantomQueue); obj = null; 12.11. 终结器引用 它用于实现对象的finalize() 方法，也可以称为终结器引用。无需手动编码，其内部配合引用队列使用。 在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象 "},"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/垃圾回收器.html":{"url":"学习资料/Java/JVM（JAVA虚拟机）/JVM上篇：内存与垃圾回收篇/垃圾回收器.html","title":"13.垃圾回收器","keywords":"","body":" 13. 垃圾回收器 13.1. GC分类与性能指标 13.1.1. 垃圾回收器概述 13.1.2. 垃圾收集器分类 13.1.3. 评估GC的性能指标 吞吐量 暂停时间 吞吐量 vs 暂停时间 13.2. 不同的垃圾回收器概述 13.2.1. 垃圾回收器发展史 13.2.2. 7种经典的垃圾收集器 13.2.3. 7款经典收集器与垃圾分代之间的关系 13.2.4. 垃圾收集器的组合关系 13.2.5. 不同的垃圾收集器概述 13.2.6. 如何查看默认垃圾收集器 13.3. Serial回收器：串行回收 13.4. ParNew回收器：并行回收 13.5. Parallel回收器：吞吐量优先 13.6. CMS回收器：低延迟 13.6.1. CMS的优点 13.6.2. CMS的弊端 13.6.3. 设置的参数 小结 13.6.4. JDK后续版本中CMS的变化 13.7. G1回收器：区域化分代式 13.7.1. G1回收器的特点（优势） 并行与并发 分代收集 空间整合 可预测的停顿时间模型（即：软实时soft real-time） 13.7.2. G1垃圾收集器的缺点 13.7.3. G1回收器的参数设置 13.7.4. G1收集器的常见操作步骤 13.7.5. G1收集器的适用场景 13.7.6. 分区Region：化整为零 13.7.7. G1垃圾回收器的回收过程 13.7.8. Remembered Set 13.7.9. G1回收过程一：年轻代GC 13.7.10. G1回收过程二：并发标记过程 13.7.11. G1回收过程三：混合回收 13.7.12. G1回收可选的过程四：Full GC 13.7.13. 补充 13.7.14. G1回收器优化建议 13.8. 垃圾回收器总结 13.8.1. 7种经典垃圾回收器总结 13.8.2. 垃圾回收器组合 13.8.3. 怎么选择垃圾回收器 13.9. GC日志分析 Minor GC日志 Full GC日志 13.X. 垃圾回收器的新发展 13.X.1. JDK11新特性 13.X.2. Open JDK12的Shenandoash GC 13.X.3. 令人震惊、革命性的ZGC 13.X.4. 其他垃圾回收器：AliGC 13. 垃圾回收器 13.1. GC分类与性能指标 13.1.1. 垃圾回收器概述 垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。 由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。 从不同角度分析垃圾收集器，可以将GC分为不同的类型。 13.1.2. 垃圾收集器分类 按线程数分，可以分为串行垃圾回收器和并行垃圾回收器。 串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。 在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中 在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。 和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。 按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。 并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。 独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。 按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。 压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。 非压缩式的垃圾回收器不进行这步操作。 按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。 13.1.3. 评估GC的性能指标 吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间） 垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。 收集频率：相对于应用程序的执行，收集操作发生的频率。 内存占用：Java堆区所占的内存大小。 快速：一个对象从诞生到被回收所经历的时间。 吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。 这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。 简单来说，主要抓住两点：吞吐量、暂停时间 吞吐量 吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）。比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。 这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的 吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4 暂停时间 “暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态。 例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。 暂停时间优先，意味着尽可能让单次STW的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5 吞吐量 vs 暂停时间 高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。 低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。 不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。 因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。 相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。 在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。 现在标准：在最大吞吐量优先的情况下，降低停顿时间 13.2. 不同的垃圾回收器概述 垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。 13.2.1. 垃圾回收器发展史 有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。 1999年随JDK1.3.1一起来的是串行方式的SerialGC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本。 2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布。 Parallel GC在JDK6之后成为HotSpot默认GC。 2012年，在JDK1.7u4版本中，G1可用。 2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。 2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。 2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 \"No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）。 2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。 2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。 2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macos和Windows上的应用 13.2.2. 7种经典的垃圾收集器 串行回收器：Serial、Serial Old 并行回收器：ParNew、Parallel Scavenge、Parallel old 并发回收器：CMS、G1 官方手册：https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf 13.2.3. 7款经典收集器与垃圾分代之间的关系 新生代收集器：Serial、ParNew、Parallel Scavenge； 老年代收集器：Serial Old、Parallel Old、CMS； 整堆收集器：G1； 13.2.4. 垃圾收集器的组合关系 两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1； 其中Serial Old作为CMS出现\"Concurrent Mode Failure\"失败的后备预案。 （红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。 （绿色虚线）JDK14中：弃用Parallel Scavenge和Serialold GC组合（JEP366） （绿色虚框）JDK14中：删除CMS垃圾回收器（JEP363） 13.2.5. 不同的垃圾收集器概述 为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。 虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。 13.2.6. 如何查看默认垃圾收集器 -XX:+PrintCommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器） 使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID 13.3. Serial回收器：串行回收 Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。 Serial收集器作为HotSpot中client模式下的默认新生代垃圾收集器。Serial收集器采用复制算法、串行回收和\"stop-the-World\"机制的方式执行内存回收。 除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial Old收集器同样也采用了串行回收和\"Stop the World\"机制，只不过内存回收算法使用的是标记-压缩算法。 Serial Old是运行在Client模式下默认的老年代的垃圾回收器 Serial Old在Server模式下主要有两个用途：① 与新生代的Parallel scavenge配合使用 ② 作为老年代CMS收集器的后备垃圾收集方案 这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World） 优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在Client模式下的虚拟机是个不错的选择。 在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。 在HotSpot虚拟机中，使用-XX:+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。等价于新生代用Serial GC，且老年代用Serial Old GC 总结 这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核cpu才可以用。现在都不是单核的了。 对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。 13.4. ParNew回收器：并行回收 如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。Par是Parallel的缩写，New：只能处理的是新生代 ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、\"Stop-the-World\"机制。 ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。 对于新生代，回收次数频繁，使用并行方式高效。 对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源） 由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比serial收集器更高效？ ParNew 收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。 但是在单个CPU的环境下，ParNew收集器不比Serial 收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。 因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作 在程序中，开发人员可以通过选项\"-XX:+UseParNewGC\"手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。 -XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。 13.5. Parallel回收器：吞吐量优先 HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和\"Stop the World\"机制。 那么Parallel 收集器的出现是否多此一举？ 和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。 自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。 高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。 Parallel 收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。 Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和\"Stop-the-World\"机制。 在程序吞吐量优先的应用场景中，Parallel 收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错。在Java8中，默认是此垃圾收集器。 参数配置 -XX:+UseParallelGC 手动指定年轻代使用Parallel并行收集器执行内存回收任务。 -XX:+UseParallelOldGC 手动指定老年代都是使用并行回收收集器。 分别适用于新生代和老年代。默认jdk8是开启的。 上面两个参数，默认开启一个，另一个也会被开启。（互相激活） -XX:ParallelGCThreads 设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。 $$ ParallelGCThreads = \\begin{cases} CPU_Count &(CPU_Count 8)\\ \\end{cases} $$ -XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒。 为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。 该参数使用需谨慎。 -XX:GCTimeRatio 垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。 取值范围（0, 100）。默认值99，也就是垃圾回收时间不超过1%。 与前一个-XX:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。 -XX:+UseAdaptivesizePolicy 设置Parallel Scavenge收集器具有自适应调节策略 在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。 13.6. CMS回收器：低延迟 在JDK1.5时期，Hotspot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。 CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。 目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。 CMS的垃圾收集算法采用标记-清除算法，并且也会\"Stop-the-World\" 不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。 在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。 CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段 初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GCRoots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。 并发标记（Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。 重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。 并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的 尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和重新标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。 另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。 CMS收集器的垃圾收集算法采用的是标记清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。 有人会觉得既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact？ 答案其实很简单，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“Stop the World” 这种场景下使用 13.6.1. CMS的优点 并发收集 低延迟 13.6.2. CMS的弊端 会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发FullGC。 CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。 CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure\"失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。 13.6.3. 设置的参数 -XX:+UseConcMarkSweepGC手动指定使用CMS收集器执行内存回收任务。 开启该参数后会自动将-xx:+UseParNewGC打开。即：ParNew（Young区用）+CMS（Old区用）+ Serial Old的组合。 -XX:CMSInitiatingOccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。 JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92% 如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低FullGc的执行次数。 -XX:+UseCMSCompactAtFullCollection 用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。 -XX:CMSFullGCsBeforeCompaction 设置在执行多少次Full GC后对内存空间进行压缩整理。 -XX:ParallelcMSThreads 设置CMS的线程数量。 CMS默认启动的线程数是（ParallelGCThreads+3）/4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。 小结 HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢？ 请记住以下口令： 如果你想要最小化地使用内存和并行开销，请选Serial GC； 如果你想要最大化应用程序的吞吐量，请选Parallel GC； 如果你想要最小化GC的中断或停顿时间，请选CMS GC。 13.6.4. JDK后续版本中CMS的变化 DK9新特性：CMS被标记为Deprecate了（JEP291） 如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX: +UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。 JDK14新特性：删除CMS垃圾回收器（JEP363） 移除了CMS垃圾收集器，如果在JDK14中使用 -XX:+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM 13.7. G1回收器：区域化分代式 既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？ 原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。 与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。 为什么名字叫 Garbage First(G1)呢？ 因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。 G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。 由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。 G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。 在JDK1.7版本正式启用，移除了Experimental的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Parallel+Parallel Old组合。被Oracle官方称为“全功能的垃圾收集器”。 与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用-XX:+UseG1GC来启用。 13.7.1. G1回收器的特点（优势） 与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示： 并行与并发 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况 分代收集 从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。 将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。 和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代； 空间整合 CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理 G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。 可预测的停顿时间模型（即：软实时soft real-time） 这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。 G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。 相比于CMSGC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。 13.7.2. G1垃圾收集器的缺点 相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。 从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。 13.7.3. G1回收器的参数设置 -XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务 -XX:G1HeapRegionSize 设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。 -XX:MaxGCPauseMillis 设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms（人的平均反应速度） -XX:+ParallelGCThread 设置STW工作线程数的值。最多设置为8（上面说过Parallel回收器的线程计算公式，当CPU_Count > 8时，ParallelGCThreads 也会大于8） -XX:ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。 -XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。 13.7.4. G1收集器的常见操作步骤 G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优： 第一步：开启G1垃圾收集器 第二步：设置堆的最大内存 第三步：设置最大的停顿时间 G1中提供了三种垃圾回收模式：Young GC、Mixed GC和Full GC，在不同的条件下被触发。 13.7.5. G1收集器的适用场景 面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜） 最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。 用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好： 超过50%的Java堆被活动数据占用； 对象分配频率或年代提升频率变化很大； GC停顿时间过长（长于0.5至1秒） HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。 13.7.6. 分区Region：化整为零 使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过-XX:G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。 虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。 一个region有可能属于Eden，Survivor或者Old/Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，S表示属于survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。 G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过0.5个region，就放到H。 设置H的原因：对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。 每个Region都是通过指针碰撞来分配空间 13.7.7. G1垃圾回收器的回收过程 G1GC的垃圾回收过程主要包括如下三个环节： 年轻代GC（Young GC） 老年代并发标记过程（Concurrent Marking） 混合回收（Mixed GC） （如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。） 顺时针，Young gc -> Young gc + Concurrent mark->Mixed GC顺序，进行垃圾回收。 应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。 当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。 标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。 举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。 13.7.8. Remembered Set 一个对象被不同区域引用的问题 一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？ 在其他的分代收集器，也存在这样的问题（而G1更突出）回收新生代也不得不同时扫描老年代？ 这样的话会降低MinorGC的效率； 解决方法： 无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：每个Region都有一个对应的Remembered Set； 每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作； 然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）； 如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中； 当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。 13.7.9. G1回收过程一：年轻代GC JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。 年轻代垃圾回收只会回收Eden区和Survivor区。 首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。 然后开始如下回收过程： 第一阶段，扫描根。根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。 第二阶段，更新RSet。处理dirty card queue（见备注）中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。 第三阶段，处理RSet。识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。 第四阶段，复制对象。此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。 第五阶段，处理引用。处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。 13.7.10. G1回收过程二：并发标记过程 初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。 根区域扫描（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在YoungGC之前完成。 并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被YoungGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。 再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。 独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集。 并发清理阶段：识别并清理完全空闲的区域。 13.7.11. G1回收过程三：混合回收 当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。 并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收 混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。 由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，-XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。 混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。 13.7.12. G1回收可选的过程四：Full GC G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。 要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。 导致G1 Full GC的原因可能有两个： Evacuation的时候没有足够的to-space来存放晋升的对象； 并发处理过程完成之前空间耗尽。 13.7.13. 补充 从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。 13.7.14. G1回收器优化建议 年轻代大小 避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小 固定年轻代的大小会覆盖暂停时间目标 暂停时间目标不要太过严苛 G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间 评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。 13.8. 垃圾回收器总结 13.8.1. 7种经典垃圾回收器总结 截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。 垃圾收集器 分类 作用位置 使用算法 特点 适用场景 Serial 串行运行 作用于新生代 复制算法 响应速度优先 适用于单CPU环境下的Client模式 ParNew 并行运行 作用于新生代 复制算法 响应速度优先 多CPU环境Server模式下与CMS配合使用 Parallel 并行运行 作用于新生代 复制算法 吞吐量优先 适用于后台运算而不需要太多交互的场景 Serial Old 串行运行 作用于老年代 标记-压缩算法 响应速度优先 适用于单CPU环境下的Client模式 Parallel Old 并行运行 作用于老年代 标记-压缩算法 吞吐量优先 适用于后台运算而不需要太多交互的场景 CMS 并发运行 作用于老年代 标记-清除算法 响应速度优先 适用于互联网或B／S业务 G1 并发、并行运行 作用于新生代、老年代 标记-压缩算法、复制算法 响应速度优先 面向服务端应用 GC发展阶段：Serial => Parallel（并行）=> CMS（并发）=> G1 => ZGC 13.8.2. 垃圾回收器组合 不同厂商、不同版本的虚拟机实现差距比较大。HotSpot虚拟机在JDK7/8后所有收集器及组合如下图 两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1; 其中Serial Old作为CMS出现＂Concurrent Mode Failure＂失败的后备预案。 红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial＋CMS、ParNew＋Serial old这两个组合声明为Deprecated（JEP 173），并在JDK 9中 完全取消了这些组合的支持（JEP214），即：移除。 （绿色虚线）JDK 14中：弃用ParallelScavenge和SeriaOold GC组合(JEP 366) （绿色虚框）JDK 14中：删除CMS垃圾回收器（JEP 363） 13.8.3. 怎么选择垃圾回收器 Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。 怎么选择垃圾收集器？ 优先调整堆的大小让JVM自适应完成 如果内存小于100M，使用串行收集器 如果是单核、单机程序，并且没有停顿时间的要求，串行收集器 如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择 如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器 官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。 最后需要明确一个观点： 没有最好的收集器，更没有万能的收集 调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器 面试 对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。 这里较通用、基础性的部分如下： 垃圾收集的算法有哪些？如何判断一个对象是否可以回收？ 垃圾收集器工作的基本流程。 另外，大家需要多关注垃圾回收器这一章的各种常用的参数 13.9. GC日志分析 通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列表 -XX:+PrintGC 输出GC日志。类似：-verbose:gc -XX:+PrintGCDetails 输出GC的详细日志 -XX:+PrintGCTimestamps 输出GC的时间戳（以基准时间的形式） -XX:+PrintGCDatestamps 输出GcC的时间戳（以日期的形式，如2013-05-04T21：53：59.234+0800） -XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息 -Xloggc:../logs/gc.log 日志文件的输出路径 打开GC日志 -verbose:gc 这个只会显示总的GC堆的变化，如下： [GC (Allocation Failure) 80832K->19298K(227840K),0.0084018 secs] [GC (Metadata GC Threshold) 109499K->21465K(228352K),0.0184066 secs] [Full GC (Metadata GC Threshold) 21465K->16716K(201728K),0.0619261 secs] 参数解析 GC、Full GC：GC的类型，GC只在新生代上进行，Full GC包括永久代，新生代，老年代。 Allocation Failure：GC发生的原因。 80832K->19298K：堆在GC前的大小和GC后的大小。 228840k：现在的堆大小。 0.0084018 secs：GC持续的时间。 打开GC日志 -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimestamps 输入信息如下 [GC (Allocation Failure) [PSYoungGen:70640K->10116K(141312K)] 80541K->20017K(227328K),0.0172573 secs] [Times:user=0.03 sys=0.00,real=0.02 secs] [GC (Metadata GC Threshold) [PSYoungGen:98859K->8154K(142336K)] 108760K->21261K(228352K),0.0151573 secs] [Times:user=0.00 sys=0.01,real=0.02 secs] [Full GC (Metadata GC Threshold)[PSYoungGen:8154K->0K(142336K)] [ParOldGen:13107K->16809K(62464K)] 21261K->16809K(204800K),[Metaspace:20599K->20599K(1067008K)],0.0639732 secs] [Times:user=0.14 sys=0.00,real=0.06 secs] 参数解析 GC，Full FC：同样是GC的类型 Allocation Failure：GC原因 PSYoungGen：使用了Parallel Scavenge并行垃圾收集器的新生代GC前后大小的变化 ParOldGen：使用了Parallel Old并行垃圾收集器的老年代GC前后大小的变化 Metaspace： 元数据区GC前后大小的变化，JDK1.8中引入了元数据区以替代永久代 xxx secs：指GC花费的时间 Times：user：指的是垃圾收集器花费的所有CPU时间，sys：花费在等待系统调用或系统事件的时间，real：GC从开始到结束的时间，包括其他进程占用时间片的实际时间。 打开GC日志 -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimestamps -XX:+PrintGCDatestamps 输入信息如下 2019-09-24T22:15:24.518+0800: 3.287: [GC (Allocation Failure) [PSYoungGen:136162K->5113K(136192K)] 141425K->17632K(222208K),0.0248249 secs] [Times:user=0.05 sys=0.00,real=0.03 secs] 2019-09-24T22:15:25.559+0800: 4.329: [GC (Metadata GC Threshold) [PSYoungGen:97578K->10068K(274944K)] 110096K->22658K(360960K),0.0094071 secs] [Times: user=0.00 sys=0.00,real=0.01 secs] 2019-09-24T22:15:25.569+0800: 4.338: [Full GC (Metadata GC Threshold) [PSYoungGen:10068K->0K(274944K)][ParoldGen:12590K->13564K(56320K)] 22658K->13564K(331264K),[Metaspace:20590K->20590K(1067008K)],0.0494875 secs] [Times: user=0.17 sys=0.02,real=0.05 secs] 说明：带上了日期和时间 如果想把GC日志存到文件的话，是下面的参数： -Xloggc:/path/to/gc.log 日志补充说明 \"[GC\"和\"[Full GC\"说明了这次垃圾收集的停顿类型，如果有\"Full\"则说明GC发生了\"Stop The World\" 使用Serial收集器在新生代的名字是Default New Generation，因此显示的是\"[DefNew\" 使用ParNew收集器在新生代的名字会变成\"[ParNew\"，意思是\"Parallel New Generation\" 使用Parallel scavenge收集器在新生代的名字是”[PSYoungGen\" 老年代的收集和新生代道理一样，名字也是收集器决定的 使用G1收集器的话，会显示为\"garbage-first heap\" Allocation Failure 表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。 [PSYoungGen：5986K->696K(8704K) ] 5986K->704K(9216K) 中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小） 括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小） user代表用户态回收耗时，sys内核态回收耗时，rea实际耗时。由于多核的原因，时间总和可能会超过real时间 Heap（堆） PSYoungGen（Parallel Scavenge收集器新生代）total 9216K，used 6234K [0x00000000ff600000,0x0000000100000000,0x0000000100000000) eden space（堆中的Eden区默认占比是8）8192K，768 used [0x00000000ff600000,0x00000000ffc16b08,0x00000000ffe00000) from space（堆中的Survivor，这里是From Survivor区默认占比是1）1024K， 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) to space（堆中的Survivor，这里是to Survivor区默认占比是1，需要先了解一下堆的分配策略）1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000) ParOldGen（老年代总大小和使用大小）total 10240K， used 7001K ［0x00000000fec00000,0x00000000ff600000,0x00000000ff600000) object space（显示个使用百分比）10240K，688 used [0x00000000fec00000,0x00000000ff2d6630,0x00000000ff600000) PSPermGen（永久代总大小和使用大小）total 21504K， used 4949K [0x00000000f9a00000,0x00000000faf00000,0x00000000fec00000) object space（显示个使用百分比，自己能算出来）21504K， 238 used [0x00000000f9a00000,0x00000000f9ed55e0,0x00000000faf00000) Minor GC日志 Full GC日志 举例 private static final int _1MB = 1024 * 1024; public static void testAllocation() { byte [] allocation1, allocation2, allocation3, allocation4; allocation1 = new byte[2 *_1MB]; allocation2 = new byte[2 *_1MB]; allocation3 = new byte[2 *_1MB]; allocation4 = new byte[4 *_1MB]; } public static void main(String[] args) { testAllocation(); } 设置JVM参数 -Xms10m -Xmx10m -XX:+PrintGCDetails 图示 可以用一些工具去分析这些GC日志 常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等 13.X. 垃圾回收器的新发展 GC仍然处于飞速发展之中，目前的默认选项G1 GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Fu11GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK10以后，Fu11GC已经是并行运行，在很多场景下，其表现还略优于ParallelGC的并行Ful1GC实现。 即使是Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在Serverless等新的应用场景下，Serial GC找到了新的舞台。 比较不幸的是CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除 13.X.1. JDK11新特性 Epsilon:A No-Op GarbageCollector（Epsilon垃圾回收器，\"No-Op（无操作）\"回收器）http://openidk.iava.net/jeps/318 ZGC:A Scalable Low-Latency Garbage Collector（Experimental）（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）http://openidk.iava.net/jeps/333 现在G1回收器已成为默认回收器好几年了。 我们还看到了引入了两个新的收集器：ZGC（JDK11出现）和Shenandoah（Open JDK12）。主打特点：低停顿时间 13.X.2. Open JDK12的Shenandoash GC Open JDK12的Shenandoash GC：低停顿时间的GC（实验性）Shenandoah，无疑是众多GC中最孤独的一个。是第一款不由oracle公司团队领导开发的Hotspot垃圾收集器。不可避免的受到官方的排挤。比如号称OpenJDK和OracleJDK没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。 Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给OpenJDK。 Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。 这是RedHat在2016年发表的论文数据，测试内容是使用Es对200GB的维基百科数据进行索引。从结果看： 停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。 而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。 总结 Shenandoah GC的弱项：高运行负担下的吞吐量下降。 Shenandoah GC的强项：低延迟时间。 Shenandoah GC的工作过程大致分为九个阶段，这里就不再赘述。在之前Java12新特性视频里有过介绍。 【Java12新特性地址】 http://www.atguigu.com/download_detail.shtml?v=222 或 https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&seid=12339069673726242866 13.X.3. 令人震惊、革命性的ZGC 官方地址：https://docs.oracle.com/en/java/javase/12/gctuning/ ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。 《深入理解Java虚拟机》一书中这样定义ZGC：ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。 ZGC的工作过程可以分为4个阶段：并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射等。 ZGC几乎在所有地方并发执行的，除了初始标记的是STw的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。 测试数据： 在ZGC的强项停顿时间测试上，它毫不留情的将Parallel、G1拉开了两个数量级的差距。无论平均停顿、95％停顿、99％停顿、99.9％停顿，还是最大停顿时间，ZGC都能毫不费劲控制在10毫秒以内。 虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。 未来将在服务端、大内存、低延迟应用的首选垃圾收集器。 JEP 364：ZGC应用在macos上JEP 365：ZGC应用在Windows上 JDK14之前，ZGC仅Linux才支持。 尽管许多使用zGc的用户都使用类Linux的环境，但在Windows和macos上，人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macos上。 现在mac或Windows上也能使用ZGC了，示例如下： -XX:+UnlockExperimentalVMOptions -XX:+UseZGC 13.X.4. 其他垃圾回收器：AliGC AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比： 当然，其它厂商也提供了各种别具一格的GC实现，例如比较有名的低延迟GC：Zing，有兴趣可以参考提供的链接 https://www.infoq.com/articles/azul_gc_in_detail "},"学习资料/Java/JVM（JAVA虚拟机）/JVM中篇：字节码与类加载篇.html":{"url":"学习资料/Java/JVM（JAVA虚拟机）/JVM中篇：字节码与类加载篇.html","title":"JVM中篇：字节码与类加载篇","keywords":"","body":"笔记来源：尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机） "},"学习资料/Java/JVM（JAVA虚拟机）/JVM下篇：性能监控与调优篇.html":{"url":"学习资料/Java/JVM（JAVA虚拟机）/JVM下篇：性能监控与调优篇.html","title":"JVM下篇：性能监控与调优篇","keywords":"","body":"笔记来源：尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机） "},"学习资料/Linux/CentOS7安装.html":{"url":"学习资料/Linux/CentOS7安装.html","title":"CentOS7安装","keywords":"","body":" CentOS 7虚拟机安装后 一、新建虚拟机 1、选择典型 2、选择CentOS镜像 3、选择存储位置 4、虚拟机磁盘配置 5、自定义其他配置 二、系统安装 1、虚拟机配置完成之后进入系统安装界面 2、选择安装语言 3、分区选择 4、开始安装 5、安装完成 三、Linux配置 CentOS 7虚拟机安装后 一、新建虚拟机 1、选择典型 2、选择CentOS镜像 3、选择存储位置 4、虚拟机磁盘配置 5、自定义其他配置 二、系统安装 1、虚拟机配置完成之后进入系统安装界面 出现此界面后敲“回车”进入安装程序 2、选择安装语言 3、分区选择 虽然默认会自动帮我们格式化磁盘，但也需要点击确认一下 点击左上角完成即可 4、开始安装 安装过程中我们可以设置密码 5、安装完成 当出现“重启”按钮时，说明系统已经安装完成 重启后的样子 至此，我们在VMware中对CentOS的基本安装已经完成 三、Linux配置 配置上网 修改配置网卡配置文件 vi /etc/sysconfig/network-scripts/ifcfg-ens33 修改 ONBOOT=yes 重启网络服务 systemctl restart network 至此，我们的虚拟机就可以访问互联网了。 "},"学习资料/Maven/Maven插件.html":{"url":"学习资料/Maven/Maven插件.html","title":"Maven插件","keywords":"","body":" Maven插件 拷贝插件 maven-antrun-plugin Maven插件 拷贝插件 maven-antrun-plugin 打包完成后,把构建结果复制到其他位置 org.apache.maven.plugins maven-antrun-plugin package package --> --> run package 表示插件要在Maven 的 package 时执行 run 这时插件内部的一个执行目标 之间可以写任何Ant支持的task "},"学习资料/扩展知识/UML类图/UML类图.html":{"url":"学习资料/扩展知识/UML类图/UML类图.html","title":"UML类图","keywords":"","body":" UML类图 1. 类图基础属性 2. 类与类之间关系 2.1 泛化（Generalization） 2.2 实现（Realization） 2.3 关联（Association） 2.4 聚合（Aggregation） 2.5 组合（Composition） 2.6 依赖（Dependency） 3.各种关系的强弱顺序 笔记来源： https://blog.csdn.net/tianhai110/article/details/6339565 https://www.jianshu.com/p/57620b762160 UML类图 1. 类图基础属性 +表示public -表示private #表示protected ~表示default,也就是包权限 _下划线表示static 斜体表示抽象 2. 类与类之间关系 在UML类图中，常见的有以下几种关系： 泛化（Generalization）， 实现（Realization）， 关联（Association）， 聚合（Aggregation）， 组合（Composition）， 依赖（Dependency） 2.1 泛化（Generalization） 【泛化关系】：是一种继承关系,它指定了子类如何特化父类的所有特征和行为。 【箭头指向】：带三角箭头的实线，箭头指向父类。 【示例】：鸟类继承抽象类动物 2.2 实现（Realization） 【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现。 【箭头指向】：带三角箭头的虚线，箭头指向接口。 【示例】：大雁需要飞翔，就要实现飞行的行为 2.3 关联（Association） 【关联关系】：对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。 关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。 【箭头指向】：带普通箭头的实心线，指向被拥有者。 【示例】：企鹅需要知道气候的变化，需要了解气候规律。当一个类知道另一个类时，可以用关联。 2.4 聚合（Aggregation） 【聚合关系】：表示一种弱的`拥有`关系，即has-a的关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。 两个对象具有各自的生命周期。 【箭头指向】：带空心菱形的实心线，菱形指向整体。 【示例】：每一只大雁都属于一个大雁群，一个大雁群可以有多只大雁。当大雁死去后大雁群并不会消失，两个对象生命周期不同。 2.5 组合（Composition） 【组合关系】：组合是一种强的`拥有`关系，是一种contains-a的关系，体现了严格的部分和整体关系，部分和整体的生命周期一样。 【箭头指向】：带实心菱形的实心线，菱形指向整体。 【示例】：鸟和翅膀就是组合关系，因为它们是部分和整体的关系，并且翅膀和鸟的生命周期是相同的。 2.6 依赖（Dependency） 【依赖关系】：对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。 ​ 尽量不使用双向的互相依赖 【代码表现】：局部变量、方法的参数或者对静态方法的调用。 【箭头指向】：带箭头的虚线，指向被使用者。 【示例】：动物依赖氧气和水。调用新陈代谢方法需要氧气类与水类的实例作为参数。 3.各种关系的强弱顺序 泛化=实现>组合>聚合>关联>依赖 下面这张UML图，比较形象地展示了各种类图关系： "},"学习资料/扩展知识/JVM分层编译/JVM分层编译.html":{"url":"学习资料/扩展知识/JVM分层编译/JVM分层编译.html","title":"JVM分层编译","keywords":"","body":" HotSpot虚拟机的分层编译（Tiered Compilation） 一、基本概念名词用于 HotSpot 虚拟机中。 二、分层编译 三、分层编译的交互关系 笔记来源： https://blog.csdn.net/u013490280/article/details/108522427 HotSpot虚拟机的分层编译（Tiered Compilation） 一、基本概念名词用于 HotSpot 虚拟机中。 提前编译（Ahead Of Time，AOT） 即时编译（Just In TIme，JIT） 解释器（Interpreter） 编译器（Compiler） 客户端编译器（Client Compiler，C1） 服务端编译器（Server Compiler，C2，也叫Opto编译器） Graal编译器（JDK 10 出现用于替代 C2） 混合模式（Mixed Mode）默认 解释模式（Interpreted Mode）-Xint 编译模式（Compiled Mode）-Xcomp Java 程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或者代码块的执行特别频繁，就会把这些代码认定为 “ 热点代码 ”（Hot Spot Code），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器被称为即时编译器。 解释执行：启动速度快。 C1 编译执行：预热较快，运行时，执行快，相对更高的编译速度。 C2 编译执行：需要较慢，运行时，执行快，相对更好的编译质量。 二、分层编译 在分层编译的工作模式出现前，HotSpot 虚拟机通常时采用解释器与其中一个编译器直接搭配的方式工作。为了在程序启动相应速度与运行效率之间达到最佳平衡，HotSpot 虚拟机在编译子系统中加入了分层编译功能。 JDK 6 时初步实现，JDK 7 开始服务端模式虚拟机中作为默认编译策略被开启。 java -XX:+PrintFlagsFinal 可以查看到 TieredCompilation 默认打开 综合了 C1 的高启动性能及 C2 的高峰值性能。这两个 JIT compiler 以及 interpreter 将 HotSpot 的执行方式划分为五个级别： level 0：interpreter 解释执行。 level 1：C1 编译，无 profiling（性能监控） level 2：C1 编译，仅方法及循环 back-edge 执行次数的 profiling level 3：C1 编译，除 level 2 中的 profiling 外还包括 branch（针对分支跳转字节码）及 receiver type（针对成员方法调用或类测，如 checkcast，instnaceof，aastore 字节码）的 profiling level 4：C2 编译 三、分层编译的交互关系 上图列举了4 种编译模式（非全部）。 通常情况下，一个方法先被解释执行（level 0），然后被C1 编译（level 3），再然后被得到profile 数据的C2 编译（level 4）。 如果编译对象非常简单，虚拟机认为通过C1 编译或通过C2 编译并无区别，便会直接由C1 编译且不插入profiling 代码（level 1）。 在C1 忙碌的情况下，interpreter 会触发profiling，而后方法会直接被C2 编译； 在C2 忙碌的情况下，方法则会先由C1 编译并保持较少的profiling（level 2），以获取较高的执行效率（与3 级相比高30%）。 "},"学习资料/扩展知识/集合类容器类/集合类容器类.html":{"url":"学习资料/扩展知识/集合类容器类/集合类容器类.html","title":"集合类容器类","keywords":"","body":"集合类/容器类 "},"学习资料/旅行攻略/昆明-大理-丽江.html":{"url":"学习资料/旅行攻略/昆明-大理-丽江.html","title":"昆明-大理-丽江","keywords":"","body":" 昆明-大理-丽江（旅行攻略） 一、交通工具 住宿 二、路线 昆明 大理 丽江 昆明-大理-丽江（旅行攻略） 一、交通工具 长沙->昆明：300元左右(飞机)1天 昆明->大理：155元左右（高铁 2~3小时） 大理->丽江：80元左右 （高铁 2~3小时）3月3号下午-3月5号下午 丽江->长沙：480元左右 3月5号晚上 长沙->昆明->大理->丽江->长沙 629+290+160+1100 住宿 大理：251+200 昆明：3月1号上午-3月1号晚上 大理：3月2号凌晨-3月3号下午 丽江：3月3号晚上-3月5号下午 二、路线 昆明 滇池 石林风景区 住宿 大理 洱海(1-3小时) 海舌生态公园(1-3小时) 喜洲古镇(1-3小时) 双廊古镇(1-3小时) 小普陀(1-3小时) http://www.mafengwo.cn/mdd/cityroute/10487_110400.html 丽江 http://www.mafengwo.cn/mdd/cityroute/10186_272.html http://www.mafengwo.cn/mdd/route/10487_316.html "}}