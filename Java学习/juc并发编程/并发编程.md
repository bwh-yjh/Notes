# 并发编程

## 一、什么是juc

### 1.1 juc简介

在 Java 中，线程部分是一个重点，本篇文章说的 JUC 也是关于线程的。JUC 就是 java.util .concurrent 工具包的简称。这是一个处理线程的工具包，JDK  1.5 开始出现的。

### 1.2 进程与线程

进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程— —资源分配的最小单位。 

线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个 单元执行流。线程——程序执行的最小单位。

### 1.3 线程的状态

#### 1.3.1 线程状态枚举类

![image-20210713165155139](并发编程.assets/image-20210713165155139.png)

#### 1.3.2  wait/sleep的区别

1. sleep是Thread类的静态方法；wait是Object的方法，任何实例对象都能调用。
2. sleep不会释放锁，它也不需要占用锁。wait会释放锁，但调用它的前提是当前线程占有锁(即代码要做synchronized中)。
3. 它们都可以被interrupted方法中断。

### 1.4 并发与并行

**并发**：同一时刻多个线程再访问同一资源，多个线程对一个点。

例子：春运抢票 电商秒杀.....

**并行**：多项工作一起执行，之后再汇总

例子：泡方便面------电水壶烧水，一边撕调料包倒入桶中

### 1.5 [管程 （monitor又称监视器）](/Java学习/juc并发编程/拓展/管程.md)

**管程**是保证了同一时刻只有一个进程在管程内活动，即管程内定义的操作在同一时刻只能被一个进程调用(由编译器实现)。



JVM同步是基于进入和退出**管程**对象实现的，每个对象都会有一个**管程**对象，**管程**会随着java对象一同创建和销毁。



执行线程首先要持有管程对象，然后才能执行方法，当方法完成之后会释放管程，方法在执行的时候会持有管程，其他线程无法再获取同一个管程。

### 1.6 用户线程和守护线程

**用户线程**：平时用到的普通线程，自定义线程

**守护线程**：运行再后台，是一种特殊的线程

**如果主线程结束，用户线程还在运行，JVM存活**

**如果没有用户现场，都是守护线程，JVM结束**

## 二、 Lock接口

### 2.1 Synchronized

#### 2.1.1 Synchronized关键字回顾

synchronized是Java中的关键字，是一种同步锁。它的修饰对象有以下几种：

1. 修饰一个代码块，被修饰的代码块被称为同步语句块，其作用的范围是大括号{ }括起来的代码，作用的对象是调用这个代码块的对象；
2. 修饰一个方法，被修饰的方法被称为同步方法，其作用范围是整个方法，作用的对象是调用这个方法的对象；
   * 虽然可以使用 synchronized 来定义方法，但 synchronized 并不属于方法定 义的一部分，因此，synchronized 关键字不能被继承。如果在父类中的某个方 法使用了 synchronized 关键字，而在子类中覆盖了这个方法，在子类中的这 个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上 synchronized 关键字才可以。当然，还可以在子类方法中调用父类中相应的方 法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此， 子类的方法也就相当于同步了。
3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；
4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分；

如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只有两种情况：

1. 获取锁的线程执行完了代码块，然后线程释放对锁的占有；
2. 线程执行时发生异常，此时JVM会让线程自动释放锁

* 那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程只能干巴巴的等待，试想一下，多么影响程序的执行效率。

  因此就需要有一种机制可以不让等待的线程一直无限期的等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。

### 2.2 什么是Lock

Lock锁实现提供了使用同步方法的语句可以获取的更广泛的锁操作。它们允许更灵活的结构，可能具有不同的属性，并且可能支持多个关联的条件的对象。Lock提供了比synchronized的更多的功能。







